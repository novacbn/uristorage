{
  "version": 3,
  "sources": ["src/adapters/whatwg_indexeddb.ts"],
  "sourcesContent": ["import Dexie, {DexieEvent} from \"dexie\";\n\nimport \"dexie-observable\";\nimport {IDatabaseChange} from \"dexie-observable/api\";\n\nimport {DEFAULT_MIME_TYPE, NODE_CHANGES, NODE_TYPES} from \"../util/constants\";\nimport {get_epoch_timestamp} from \"../util/datetime\";\nimport {IEvent, event} from \"../util/event\";\nimport {make_glob} from \"../util/glob\";\nimport {get_mime_type} from \"../util/mime_types\";\nimport {join, normalize} from \"../util/path\";\n\nimport {\n    IBaseAdapterOptions,\n    INode,\n    IQueryOptions,\n    IQueryResult,\n    IWatchEvent,\n    IURLObject,\n    BaseAdapter,\n    create_url_object,\n    IWatchOptions,\n    hook_watcher,\n} from \"./base_adapter\";\n\nconst INDEXEDDB_VERSION = 1;\n\n/**\n * Represents a persisted Node in a `IndexedDBAdapter` Adapter\n *\n * @internal\n */\ninterface IIndexedDBNode extends INode {\n    /**\n     * Represents the binary payload currently stored with the Node\n     */\n    payload?: Uint8Array;\n}\n\n/**\n * Represents the `Dexie` implementation used for IndexedDB persistence\n *\n * @internal\n */\nclass IndexedDBStorage extends Dexie {\n    EVENT_WATCH: IEvent<IWatchEvent>;\n\n    /**\n     * Represents the database table that stores persisted Nodes\n     */\n    nodes: Dexie.Table<IIndexedDBNode, string>;\n\n    constructor(namespace = \"default\") {\n        super(\"uristorage:\" + namespace);\n\n        this.version(INDEXEDDB_VERSION).stores({\n            nodes: \"&path, ctime, mime_type, mtime, type\",\n        });\n\n        this.nodes = this.table(\"nodes\");\n\n        this.EVENT_WATCH = event((dispatch) => {\n            function on_change(event: IDatabaseChange[]) {\n                for (const change of event) {\n                    // HACK: `DatabaseChangeType` from `dexie-observable` is a const expression\n                    // enumeration. So we can't use it as a variable. Thus we need TypeScript to ignore\n                    // errors about types it cannot determine\n                    switch (change.type) {\n                        case 1: // DatabaseChangeType.Create\n                            dispatch({\n                                change: NODE_CHANGES.created,\n                                // @ts-ignore\n                                path: change.obj.path,\n                                // @ts-ignore\n                                type: change.obj.type,\n                            });\n\n                            break;\n\n                        case 3: // DatabaseChangeType.Delete\n                            dispatch({\n                                change: NODE_CHANGES.removed,\n                                // @ts-ignore\n                                path: change.oldObj.path,\n                                // @ts-ignore\n                                type: change.oldObj.path,\n                            });\n\n                            break;\n\n                        case 2: // DatabaseChangeType.Update\n                            // @ts-ignore\n                            if (change.mods.payload) {\n                                dispatch({\n                                    change: NODE_CHANGES.attached,\n                                    // @ts-ignore\n                                    path: change.oldObj.path,\n                                    // @ts-ignore\n                                    type: change.oldObj.path,\n                                });\n                            } else {\n                                dispatch({\n                                    change: NODE_CHANGES.updated,\n                                    // @ts-ignore\n                                    path: change.oldObj.path,\n                                    // @ts-ignore\n                                    type: change.oldObj.path,\n                                });\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            // HACK: Like above, the types for `dexie-observable` are meh. So\n            // we need have TypeScript to ignore errors again\n\n            // @ts-ignore\n            const context = this.on(\"changes\", on_change) as DexieEvent;\n            return () => context.unsubscribe(on_change);\n        });\n    }\n}\n\n/**\n * Represents a URIStorage Adapter that persists all data into the Browser's [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)\n */\nexport class IndexedDBAdapter extends BaseAdapter {\n    static can_hotlink = true;\n\n    static can_watch = true;\n\n    static is_available = !!(typeof window === \"object\" && window.indexedDB);\n\n    static requires_mount = true;\n\n    /**\n     * Represents the IndexedDB storage for Nodes\n     *\n     * @internal\n     */\n    storage?: IndexedDBStorage;\n\n    constructor(options: Partial<IBaseAdapterOptions> = {}) {\n        super(options);\n    }\n\n    async create_url_object(path: string): Promise<IURLObject> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'create_url_object' (database is not mounted)\");\n        }\n\n        const uri = this.normalize(path);\n        const node = await storage.nodes.get(uri);\n        if (!node) {\n            throw new Error(\n                \"bad argument #0 to 'create_url_object' (Node must be created before using 'create_url_object')\"\n            );\n        }\n\n        if (!node.payload) {\n            throw new Error(\n                \"bad argument #0 to 'create_url_object' (Node payload must be created before using 'create_url_object')\"\n            );\n        }\n\n        const object = create_url_object(node.payload, node.mime_type);\n\n        return {\n            destroy: object.destroy,\n            path: node.path,\n            url: object.url,\n        };\n    }\n\n    async get(path: string): Promise<INode | null> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'get' (database is not mounted)\");\n        }\n\n        const uri = this.normalize(path);\n        const node = await storage.nodes.get(uri);\n        if (!node) return null;\n\n        return {\n            ctime: node.ctime,\n            mime_type: node.mime_type,\n            mtime: node.mtime,\n            path: node.path,\n            type: node.type,\n        };\n    }\n\n    /**\n     * Persists a new or updates an existing Node with new metadata. Optionally can specify the Node's [[NODE_TYPES]]\n     *\n     * > **NOTE**: Will try to guess the Mime Type if `mime_type` is `undefined`\n     *\n     * @param path\n     * @param type\n     * @param mime_type\n     */\n    async put(\n        path: string,\n        type: NODE_TYPES = NODE_TYPES.undefined,\n        mime_type?: string\n    ): Promise<void> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'put' (database is not mounted)\");\n        }\n\n        const uri = this.normalize(path);\n        const node = await storage.nodes.get(uri);\n\n        const timestamp = get_epoch_timestamp();\n        if (!mime_type) mime_type = get_mime_type(uri) || DEFAULT_MIME_TYPE;\n\n        if (node) {\n            await storage.nodes.update(node, {\n                mtime: timestamp,\n                mime_type,\n                type,\n            });\n        } else {\n            await storage.nodes.put({\n                ctime: timestamp,\n                mime_type,\n                mtime: timestamp,\n                path: uri,\n                type,\n            });\n        }\n    }\n\n    async query(options: IQueryOptions = {}): Promise<IQueryResult[]> {\n        // TODO: This is probably slow with tons and tons of entries... can\n        // this be handled in a better way?\n        //\n        // The issue is that you can only have one `WhereClause` available at a\n        // time. Not only that, but we need to support optional filters anyway\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'query' (database is not mounted)\");\n        }\n\n        const {path = {}, type} = options;\n        let collection = storage.nodes.toCollection();\n\n        if (type) {\n            if (typeof type === \"string\") {\n                collection = collection.filter((node) => node.type === type);\n            } else collection = collection.filter((node) => type.includes(node.type));\n        }\n\n        if (path.glob) {\n            const regex = make_glob(normalize(path.glob));\n\n            collection = collection.filter((node) => regex.test(node.path));\n        } else if (path.regex) {\n            const {regex} = path;\n\n            collection = collection.filter((node) => regex.test(node.path));\n        } else {\n            // TODO: Technically if the end-developer provides a `.path` member, they\n            // can just pass a glob pattern. Should we sanitize?\n            let {path: _path = \"/\"} = path;\n\n            _path = path.recursive ? join(_path, \"**\") : join(_path, \"*\");\n            const regex = make_glob(normalize(_path));\n\n            collection = collection.filter((node) => regex.test(node.path));\n        }\n\n        const results = await collection.toArray();\n\n        return results.map((node, index) => {\n            const {path, type} = node;\n\n            return {path, type};\n        });\n    }\n\n    async read(path: string): Promise<Uint8Array | null> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'get_payload' (database is not mounted)\");\n        }\n\n        const uri = this.normalize(path);\n        const node = await storage.nodes.get(uri);\n        if (!node || !node.payload) return null;\n\n        return node.payload;\n    }\n\n    async remove(path: string): Promise<boolean> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'remove' (database is not mounted)\");\n        }\n\n        const uri = this.normalize(path);\n        const node = await storage.nodes.get(uri);\n        if (!node) return false;\n\n        storage.nodes.delete(uri);\n        return true;\n    }\n\n    async watch(options: IWatchOptions = {}): Promise<IEvent<IWatchEvent>> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'remove' (database is not mounted)\");\n        }\n\n        return hook_watcher(storage.EVENT_WATCH, options);\n    }\n\n    async write(path: string, payload: Uint8Array): Promise<void> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'attach' (database is not mounted)\");\n        }\n\n        const uri = this.normalize(path);\n        const node = await storage.nodes.get(uri);\n        if (!node) {\n            throw new Error(\n                \"bad argument #0 to 'attach' (Node must be created before using 'attach')\"\n            );\n        }\n\n        await storage.nodes.update(node, {\n            payload,\n            mtime: get_epoch_timestamp(),\n        });\n    }\n\n    is_mounted(): boolean {\n        return !!this.storage;\n    }\n\n    async mount(): Promise<void> {\n        if (this.storage) {\n            throw new Error(\"bad dispatch to 'mount' (database is already mounted)\");\n        }\n\n        const {namespace} = this.options;\n        const storage = new IndexedDBStorage(namespace);\n\n        await storage.open();\n        this.storage = storage;\n    }\n\n    async unmount(): Promise<void> {\n        const {storage} = this;\n        if (!storage) {\n            throw new Error(\"bad dispatch to 'unmount' (database is not mounted)\");\n        }\n\n        await storage.close();\n        delete this.storage;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
