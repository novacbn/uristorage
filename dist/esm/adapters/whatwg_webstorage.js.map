{
  "version": 3,
  "sources": ["../../../src/adapters/whatwg_webstorage.ts"],
  "sourcesContent": ["import {compress, decompress} from \"../util/compression\";\nimport {NODE_CHANGES, DEFAULT_MIME_TYPE, ENCODING_MODE, NODE_TYPES} from \"../util/constants\";\nimport {get_epoch_timestamp} from \"../util/datetime\";\nimport {decode_safe, encode_safe} from \"../util/encoding\";\nimport {IEvent, event} from \"../util/event\";\nimport {get_mime_type} from \"../util/mime_types\";\n\nimport {\n    IBaseAdapterOptions,\n    INode,\n    IQueryOptions,\n    IQueryResult,\n    IURLObject,\n    IWatchEvent,\n    IWatchOptions,\n    BaseAdapter,\n    create_url_object,\n    filter_query,\n    hook_watcher,\n} from \"./base_adapter\";\n\n/**\n * Represents the options passable to [[WebStorageAdapter]]\n */\nexport interface IWebStorageOptions extends IBaseAdapterOptions {\n    /**\n     * Represents if LZ77 Compression should be used for binary payloads for persistence\n     *\n     * > **NOTE**: Depending on the size of the payload and other factors, this can\n     * > incur a CPU performance impact\n     */\n    compressed: boolean;\n}\n\n/**\n * ...\n *\n * @internal\n */\nclass WebStorage {\n    /**\n     * Event that dispatches whenever there is a creation / update in the Web Storage\n     */\n    EVENT_WATCH = event<IWatchEvent>();\n\n    /**\n     * Represents the Node metadata prefix for all the persisted key names\n     */\n    prefix_node: string;\n\n    /**\n     * Represents the binary payload prefix for all the persisted key names\n     */\n    prefix_payload: string;\n\n    /**\n     * Represents the validated [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API) that's being targetted\n     *\n     * @internal\n     */\n    storage: Storage;\n\n    constructor(namespace: string, storage: Storage) {\n        this.prefix_node = `uristorage:${namespace}:n:`;\n        this.prefix_payload = `uristorage:${namespace}:p:`;\n\n        this.storage = storage;\n    }\n\n    attach(path: string, payload: Uint8Array, mtime: number): void {\n        const {storage} = this;\n\n        const key_node = this.prefix_node + path;\n        const key_payload = this.prefix_payload + path;\n\n        const node: INode = {...JSON.parse(storage.getItem(key_node) as string), mtime};\n\n        storage.setItem(key_node, JSON.stringify(node));\n        storage.setItem(key_payload, encode_safe(payload));\n\n        this.EVENT_WATCH.dispatch({\n            change: NODE_CHANGES.attached,\n            path: path,\n            type: node.type,\n        });\n    }\n\n    get(path: string): INode | null {\n        const key = this.prefix_node + path;\n        const item = this.storage.getItem(key);\n\n        if (item) {\n            // NOTE: There could be unsupported or missing metadata, so we need to extract and default\n            const {\n                ctime = 0.0,\n                mime_type = DEFAULT_MIME_TYPE,\n                mtime = 0.0,\n                type = NODE_TYPES.undefined,\n            } = JSON.parse(item);\n\n            return {\n                ctime,\n                mime_type,\n                mtime,\n                path,\n                type,\n            };\n        }\n\n        return null;\n    }\n\n    get_payload(path: string): Uint8Array | null {\n        const key = this.prefix_payload + path;\n        const item = this.storage.getItem(key);\n\n        if (item) return decode_safe(item, {mode: ENCODING_MODE.bytes});\n        return null;\n    }\n\n    has(path: string): boolean {\n        path = this.prefix_node + path;\n\n        return !!this.storage.getItem(path);\n    }\n\n    *nodes(): Generator<IQueryResult> {\n        const {prefix_node, storage} = this;\n\n        for (let index = 0; index < storage.length; index++) {\n            const key = storage.key(index);\n            if (key?.startsWith(prefix_node)) {\n                const item = storage.getItem(key);\n                const {type = NODE_TYPES.undefined} = JSON.parse(item as string);\n\n                yield {\n                    path: key.slice(prefix_node.length),\n                    type,\n                };\n            }\n        }\n    }\n\n    put(path: string, node: Omit<INode, \"path\">): void {\n        const _node: INode = {...node, path};\n        const item = JSON.stringify(_node);\n\n        this.storage.setItem(this.prefix_node + path, item);\n\n        this.EVENT_WATCH.dispatch({\n            change: NODE_CHANGES.created,\n            path: path,\n            type: _node.type,\n        });\n    }\n\n    remove(path: string): boolean {\n        const {storage} = this;\n\n        const item = storage.getItem(path);\n        if (!item) return false;\n\n        const node = JSON.parse(item);\n\n        // NOTE: Always remove the payload from Web Storage, zero performance cost anyway\n        storage.removeItem(this.prefix_node + path);\n        storage.removeItem(this.prefix_payload + path);\n\n        this.EVENT_WATCH.dispatch({\n            change: NODE_CHANGES.removed,\n            path: path,\n            type: node.type,\n        });\n\n        return true;\n    }\n\n    update(path: string, value: Partial<INode>): void {\n        const {storage} = this;\n\n        const key = this.prefix_node + path;\n        const node: INode = {...JSON.parse(storage.getItem(key) as string), ...value, path};\n\n        storage.setItem(key, JSON.stringify(node));\n\n        this.EVENT_WATCH.dispatch({\n            change: NODE_CHANGES.updated,\n            path: node.path,\n            type: node.type,\n        });\n    }\n}\n\n/**\n * Returns standardized options w/ defaults of [[iWebStorageOptions]]\n *\n * @internal\n *\n * @param options\n */\nfunction WebStorageOptions(options: Partial<IWebStorageOptions> = {}): Partial<IWebStorageOptions> {\n    const {compressed = true} = options;\n\n    return {\n        ...options,\n\n        compressed,\n    };\n}\n\n/**\n * Represents a URIStorage Adapter that targets the Browsers' [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)\n */\nexport class WebStorageAdapter extends BaseAdapter {\n    // NOTE: While `localStorage` / `sessionStorage` are synchronous, we\n    // need to conform to the Promise-based API\n\n    // TODO: Can probably clean up the implementation\n\n    // TODO: Hook [`StorageEvent`](https://developer.mozilla.org/en-US/docs/Web/API/StorageEvent) for cross-tab updates\n    // also maybe utilize a global `EVENT_WATCH` instead of one per-instance?\n\n    static can_hotlink = true;\n\n    static can_watch = true;\n\n    static is_available = false;\n\n    /**\n     * Represents the target [Web Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API) to utilize\n     */\n    static storage: Storage | null = null;\n\n    storage: WebStorage;\n\n    options!: IWebStorageOptions;\n\n    constructor(storage: Storage, options: Partial<IWebStorageOptions> = {}) {\n        super(WebStorageOptions(options));\n\n        const {namespace} = this.options;\n\n        this.storage = new WebStorage(namespace, storage);\n    }\n\n    async create_url_object(path: string): Promise<IURLObject> {\n        const {storage} = this;\n        const {compressed} = this.options;\n\n        const uri = this.normalize(path);\n        if (!storage.has(uri)) {\n            throw new Error(\n                \"bad argument #0 to 'create_url_object' (Node must be created before using 'create_url_object')\"\n            );\n        }\n\n        let payload = storage.get_payload(uri);\n        if (!payload) {\n            throw new Error(\n                \"bad argument #0 to 'create_url_object' (Node payload must be created before using 'create_url_object')\"\n            );\n        }\n\n        const node = storage.get(uri) as INode;\n        payload = compressed ? decompress(payload) : payload;\n\n        const object = create_url_object(payload, node.mime_type);\n\n        return {\n            destroy: object.destroy,\n            path: node.path,\n            url: object.url,\n        };\n    }\n\n    async get(path: string): Promise<INode | null> {\n        const uri = this.normalize(path);\n\n        return this.storage.get(uri);\n    }\n\n    /**\n     * Persists a new or updates an existing Node with new metadata. Optionally can specify the Node's [[NODE_TYPES]]\n     *\n     * > **NOTE**: Will try to guess the Mime Type if `mime_type` is `undefined`\n     *\n     * @param path\n     * @param type\n     * @param mime_type\n     */\n    async put(\n        path: string,\n        type: NODE_TYPES = NODE_TYPES.undefined,\n        mime_type?: string\n    ): Promise<void> {\n        const {storage} = this;\n\n        const uri = this.normalize(path);\n        const timestamp = get_epoch_timestamp();\n        if (!mime_type) mime_type = get_mime_type(uri) || DEFAULT_MIME_TYPE;\n\n        if (storage.has(uri)) {\n            storage.update(uri, {\n                mime_type,\n                mtime: timestamp,\n                type,\n            });\n        } else {\n            storage.put(uri, {\n                ctime: timestamp,\n                mime_type,\n                mtime: timestamp,\n                type,\n            });\n        }\n    }\n\n    async query(options: IQueryOptions = {}): Promise<IQueryResult[]> {\n        const nodes = Array.from(this.storage.nodes());\n\n        return filter_query(nodes, options);\n    }\n\n    async read(path: string): Promise<Uint8Array | null> {\n        const {compressed} = this.options;\n\n        const uri = this.normalize(path);\n        const payload = this.storage.get_payload(uri);\n\n        if (!payload) return null;\n        return compressed ? decompress(payload) : payload;\n    }\n\n    async remove(path: string): Promise<boolean> {\n        const uri = this.normalize(path);\n\n        return this.storage.remove(uri);\n    }\n\n    async watch(options: IWatchOptions = {}): Promise<IEvent<IWatchEvent>> {\n        return hook_watcher(this.storage.EVENT_WATCH, options);\n    }\n\n    async write(path: string, payload: Uint8Array): Promise<void> {\n        const {storage} = this;\n        const {compressed} = this.options;\n\n        const uri = this.normalize(path);\n        if (!storage.has(uri)) {\n            throw new Error(\n                \"bad argument #0 to 'attach' (Node must be created before using 'attach')\"\n            );\n        }\n\n        payload = compressed ? compress(payload) : payload;\n        storage.attach(uri, payload, get_epoch_timestamp());\n    }\n\n    is_mounted(): boolean {\n        return true;\n    }\n\n    async mount(): Promise<void> {}\n\n    async unmount(): Promise<void> {}\n}\n\n/**\n * Represents a URIStorage Adapter that targets the Browsers' [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)\n *\n * > **NOTE**: Some Browsers may delete `localStorage` contents after a period of in-activity and may enforce harsh storage limits, e.g. 5 MB max\n */\nexport class LocalStorageAdapter extends WebStorageAdapter {\n    static is_available = !!(typeof window === \"object\" && window.localStorage);\n\n    constructor(options: Partial<IWebStorageOptions> = {}) {\n        super(window.localStorage, options);\n    }\n}\n\n/**\n * Represents a URIStorage Adapter that targets the Browsers' [sessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)\n *\n * > **NOTE**: Browsers delete `sessionStorage` contents after a browsing session is closed and may enforce harsh storage limits, e.g. 5 MB max\n */\nexport class SessionStorageAdapter extends WebStorageAdapter {\n    static is_available = !!(typeof window === \"object\" && window.sessionStorage);\n\n    constructor(options: Partial<IWebStorageOptions> = {}) {\n        super(window.sessionStorage, options);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
