{
  "version": 3,
  "sources": ["../../../src/adapters/base_adapter.ts"],
  "sourcesContent": ["import {NODE_CHANGES, NODE_TYPES, DEFAULT_MIME_TYPE} from \"../util/constants\";\nimport {IEvent, event} from \"../util/event\";\nimport {make_glob} from \"../util/glob\";\nimport {join, normalize} from \"../util/path\";\n\n/**\n * Represents the options passable to [[BaseAdapter]]\n */\nexport interface IBaseAdapterOptions {\n    /**\n     * Represents the namespace used for the Adapter\n     *\n     * > **NOTE**: There is no base format for namespaces, it is dependent on the Adapter!\n     */\n    namespace: string;\n}\n\n/**\n * Represents the event details dispatched to subscribers via [[BaseAdapter.EVENT_MOUNTED]] / [[BaseAdapter.EVENT_UNMOUNTED]]\n */\nexport interface IMountedEvent {\n    storage: BaseAdapter;\n}\n\n/**\n * Represents the Node stats returned by [[BaseAdapter.get_stats]]\n */\nexport interface INode {\n    /**\n     * Represents the creation time of the Node in milliseconds since UNIX Epoch in UTC\n     */\n    ctime: number;\n\n    /**\n     * Represents the Mime Type associated with how the Node's payload should be handled\n     */\n    mime_type: string;\n\n    /**\n     * Represents the last updated time of the Node in milliseconds since UNIX Epoch in UTC\n     */\n    mtime: number;\n\n    /**\n     * Represents the path associated with the Node\n     */\n    path: string;\n\n    /**\n     * Represents what type of Node it is\n     */\n    type: NODE_TYPES;\n}\n\n/**\n * Represents the options passable to [[BaseAdapter.query]]\n */\nexport interface IQueryOptions {\n    /**\n     * Represents the type of Node to filter for\n     */\n    type?: NODE_TYPES | NODE_TYPES[];\n\n    /**\n     * Represents filter applicable to Node paths\n     */\n    path?: {\n        /**\n         * Represents a [Bash Shell Glob](https://en.wikipedia.org/wiki/Glob_(programming)) pattern to match paths with\n         *\n         * > **NOTE**: When using \"Globstar\", \"**\", the backend will search recursively for sub-paths, which may incur a performance penalty\n         */\n        glob?: string;\n\n        /**\n         * Represents to search for Nodes that start with the given path\n         */\n        path?: string;\n\n        /**\n         * Represents if the [[IQueryOptions.path.path]] should be recursively queried for sub-paths or not\n         *\n         * > **NOTE**: When set to `true`, the backend will search recursively for sub-paths, which may incur a performance penalty\n         */\n        recursive?: boolean;\n\n        /**\n         * Represents a [Regular Expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to match paths with\n         *\n         * > **NOTE**: When using the \"Global Match\" flag, \"g\", the backend will search recursively for sub-paths, which may incur a performance penalty\n         */\n        regex?: RegExp;\n    };\n}\n\n/**\n * Represents the struct returned by [[BaseAdapter.query]] for matching Nodes\n */\nexport interface IQueryResult {\n    /**\n     * Represents the path of the Node matched\n     */\n    path: string;\n\n    /**\n     * Represents the type of Node matched\n     */\n    type: NODE_TYPES;\n}\n\n/**\n * Represents the return value from [[BaseAdapter.create_url_object]]\n */\nexport interface IURLObject {\n    /**\n     * Represents the path used to create the [[IURLObject]]\n     */\n    path: string;\n\n    /**\n     * Represents the URL string usable for embeding via HTML tags, e.g. `<img src=\"...value of IURLObject.url...\" />`\n     */\n    url: string;\n\n    /**\n     * Removes the URL object from memory, performing any clean-up necessary\n     *\n     * > **NOTE**: This function should only be called once\n     */\n    destroy: () => Promise<void>;\n}\n\n/**\n * Represents the event details dispatched to subscribers via [[BaseAdapter.watch]]\n */\nexport interface IWatchEvent {\n    /**\n     * Represents the type of change that occured with the Node\n     */\n    change: NODE_CHANGES;\n\n    /**\n     * Represents the path of the Node that was created / updated\n     */\n    path: string;\n\n    /**\n     * Represents the type of Node that was created / updated\n     */\n    type: NODE_TYPES;\n}\n\n/**\n * Represents the options passable to [[BaseAdapter.watch]]\n */\nexport interface IWatchOptions {\n    /**\n     * Represents which types of update method to watch the Node path for\n     */\n    change?: NODE_CHANGES | NODE_CHANGES[];\n\n    /**\n     * Represents a [Bash Shell Glob](https://en.wikipedia.org/wiki/Glob_(programming)) pattern to match paths with\n     *\n     * > **NOTE**: When using \"Globstar\", \"**\", the backend will watch recursively for sub-paths, which may incur a performance penalty\n     */\n    glob?: string;\n\n    /**\n     * Represents if [[IWatchOptions.path]] should watch for sub-paths instead of a singular Node path\n     */\n    inclusive?: boolean;\n\n    /**\n     * Represents a singular Node path to watch for changes\n     */\n    path?: string;\n\n    /**\n     * Represents if [[IWatchOptions.path]] should watch for changes that happen in sub-paths as well.\n     *\n     * > **NOTE**: Only applicable whenever [[IWatchOptions.inclusive]] is `true`\n     */\n    recursive?: boolean;\n\n    /**\n     * Represents a [Regular Expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to match paths with\n     *\n     * > **NOTE**: When using the \"Global Match\" flag, \"g\", the backend will watch recursively for sub-paths, which may incur a performance penalty\n     */\n    regex?: RegExp;\n\n    /**\n     * Represents the type of Nodes to watch only for\n     */\n    type?: NODE_TYPES | NODE_TYPES[];\n}\n\n/**\n * Returns standardized options w/ defaults of [[IBaseAdapterOptions]]\n *\n * @internal\n *\n * @param options\n */\nfunction BaseAdapterOptions(options: Partial<IBaseAdapterOptions> = {}): IBaseAdapterOptions {\n    const {namespace = \"default\"} = options;\n\n    return {\n        ...options,\n\n        namespace,\n    };\n}\n\n/**\n * Returns a newly created URL object that the Browser can use for embeds, e.g. `<img src=\"...\" />` tags\n *\n * > **NOTE**: This function is normally performed by an Adapter's backend if it can be represented\n *\n * @param payload\n */\nexport function create_url_object(payload: Blob): {destroy: () => Promise<void>; url: string};\nexport function create_url_object(\n    payload: Uint8Array,\n    mime_type: string\n): {destroy: () => Promise<void>; url: string};\nexport function create_url_object(\n    payload: Blob | Uint8Array,\n    mime_type?: string\n): {destroy: () => Promise<void>; url: string} {\n    if (payload instanceof Uint8Array) {\n        if (!mime_type) mime_type = DEFAULT_MIME_TYPE;\n        payload = new Blob([payload], {type: mime_type});\n    }\n\n    const url = URL.createObjectURL(payload);\n\n    return {\n        url,\n        destroy: async () => URL.revokeObjectURL(url),\n    };\n}\n\n/**\n * Returns `true` if the provided [[IWatchEvent]] event is validated against the [[IWatchOptions]] for [[BaseAdapter.watch]]\n *\n * > **NOTE**: This function is normally performed by an Adapter's backend if it can be represented\n *\n * @param event\n * @param options\n */\nexport function can_watch(event: IWatchEvent, options: IWatchOptions = {}): boolean {\n    const {change, glob, inclusive = false, path = \"/\", recursive = false, regex, type} = options;\n\n    if (type) {\n        if (typeof type === \"string\") {\n            if (event.type !== type) return false;\n        } else if (!type.includes(event.type)) return false;\n    }\n\n    if (change) {\n        if (typeof change === \"string\") {\n            if (change !== event.change) return false;\n        } else if (!change.includes(event.change)) return false;\n    }\n\n    // NOTE: Only one one mode of filters should be accepted at a time. While\n    // the order of priority here is arbitrary. It should be recognized in\n    // other backend Adapters for consistency\n    if (glob) {\n        const regex = make_glob(normalize(glob));\n\n        return regex.test(event.path);\n    } else if (regex) {\n        return regex.test(event.path);\n    } else {\n        if (inclusive) {\n            const _path = recursive ? join(path, \"**\") : join(path, \"*\");\n            const regex = make_glob(normalize(_path));\n\n            return regex.test(event.path);\n        }\n\n        return event.path === normalize(path);\n    }\n}\n\n/**\n * Returns a in-memory filtering of results from [[BaseAdapter.query]]\n *\n * > **NOTE**: This function is normally performed by an Adapter's backend if it can be represented\n *\n * @param nodes\n * @param options\n */\nexport function filter_query(nodes: IQueryResult[], options: IQueryOptions = {}): IQueryResult[] {\n    const {path = {}, type} = options;\n\n    if (type) {\n        if (typeof type === \"string\") nodes = nodes.filter((node) => node.type === type);\n        else nodes = nodes.filter((node) => type.includes(node.type));\n    }\n\n    // NOTE: Only one one mode of querying should be accepted at a time. While\n    // the order of priority here is arbitrary. It should be recognized in\n    // other backend Adapters for consistency\n    if (path.glob) {\n        const regex = make_glob(normalize(path.glob));\n\n        nodes = nodes.filter((node) => regex.test(node.path));\n    } else if (path.regex) {\n        const {regex} = path;\n\n        nodes = nodes.filter((node) => regex.test(node.path));\n    } else {\n        // TODO: Technically if the end-developer provides a `.path` member, they\n        // can just pass a glob pattern. Should we sanitize?\n        let {path: _path = \"/\"} = path;\n\n        _path = path.recursive ? join(_path, \"**\") : join(_path, \"*\");\n        const regex = make_glob(normalize(_path));\n\n        nodes = nodes.filter((node) => regex.test(node.path));\n    }\n\n    return nodes;\n}\n\n/**\n * Returns a new `IEvent` that only dispatches events from the watcher that match the filter\n *\n * > **NOTE**: This function is normally performed by an Adapter's backend if it can be represented\n *\n * @param watcher\n * @param options\n */\nexport function hook_watcher(\n    watcher: IEvent<IWatchEvent>,\n    options: IWatchOptions = {}\n): IEvent<IWatchEvent> {\n    return event((dispatch) => {\n        const destroy = watcher.subscribe((event) => {\n            if (can_watch(event, options)) dispatch(event);\n        });\n\n        return () => destroy();\n    });\n}\n\n/**\n * Represents the base common API all URIStorage Adapters ad-here to\n */\nexport class BaseAdapter {\n    /**\n     * Represents of the Adapter can utilize [[BaseAdapter.create_url_object]]\n     */\n    static can_hotlink: boolean = false;\n\n    /**\n     * Represents if the Adapter can utilize [[BaseAdapter.watch]]\n     */\n    static can_watch: boolean = false;\n\n    /**\n     * Represents if the Adapter can utilize [[BaseAdapter.watch]] but requires periodic calls to [[BaseAdapter.reload]]\n     */\n    static can_watch_reload: boolean = false;\n\n    /**\n     * Represents if the Adapter is available in the current Javascript environment\n     */\n    static is_available: boolean = false;\n\n    /**\n     * Represents if the Adapter is read-only\n     */\n    static is_readonly: boolean = false;\n\n    /**\n     * Represents if the Adapter requires mounting first, to be used\n     */\n    static requires_mount: boolean = false;\n\n    /**\n     * Event that dispatches whenever the Adapter is mounted\n     */\n    EVENT_MOUNTED = event<IMountedEvent>();\n\n    /**\n     * Event that dispatches whenever the Adapter is unmounted\n     */\n    EVENT_UNMOUNTED = event<IMountedEvent>();\n\n    /**\n     * Represents the standardized options passed into the constructor\n     */\n    options: IBaseAdapterOptions;\n\n    constructor(options: Partial<IBaseAdapterOptions> = {}) {\n        this.options = BaseAdapterOptions(options);\n    }\n\n    /**\n     * Returns the `path` normalized for the given Adapter\n     *\n     * @internal\n     *\n     * @param path\n     */\n    normalize(path: string): string {\n        return normalize(path);\n    }\n\n    /**\n     * Returns a new [[IURLObject]] linking to the given `path`\n     *\n     * > **NOTE**: Will not work with [[BaseAdapter.can_hotlink]] is `false` for the given Adapter\n     **\n     * @param path\n     */\n    async create_url_object(path: string): Promise<IURLObject> {\n        throw new Error(\"bad dispatch to 'create_url_object' (not implemented)\");\n    }\n\n    /**\n     * Returns the [[INode]] struct of the requested path, or `null` if non-existant\n     * @param path\n     */\n    async get(path: string): Promise<INode | null> {\n        throw new Error(\"bad dispatch to 'get' (not implemented)\");\n    }\n\n    /**\n     * Persists a new or updates an existing Node with new metadata. Optionally can specify the Node's [[NODE_TYPES]]\n     *\n     * > **NOTE**: Not all Adapters utilize `mime_type` input, depending on backend, it might automatically be handled\n     *\n     * @param path\n     * @param type\n     * @param mime_type\n     */\n    async put(\n        path: string,\n        type: NODE_TYPES = NODE_TYPES.undefined,\n        mime_type?: string\n    ): Promise<void> {\n        throw new Error(\"bad dispatch to 'put' (not implemented)\");\n    }\n\n    /**\n     * Queries the Adapter for listings of currently persisted Nodes, with optional filtering\n     * parameters to narrow down return results\n     *\n     * @param options\n     */\n    async query(options: IQueryOptions = {}): Promise<IQueryResult[]> {\n        throw new Error(\"bad dispatch to 'query' (not implemented)\");\n    }\n\n    /**\n     * Returns the binary payload of the requested path, or `null` if non-existant\n     * @param path\n     */\n    async read(path: string): Promise<Uint8Array | null> {\n        throw new Error(\"bad dispatch to 'get_stats' (not implemented)\");\n    }\n\n    /**\n     * Polls the Adapter for any new changes since any previous calls to [[BaseAdapter.watch]] was\n     * performed. Dispatching to the relevant subscribers\n     *\n     * > **NOTE**: Only call this if the Adapter's [[BaseAdapter.can_watch_reload]] is `true`\n     */\n    async reload(): Promise<void> {\n        throw new Error(\"bad dispatch to 'reload' (not implemented)\");\n    }\n\n    /**\n     * Removes the Node by the given `path`, returns true if successful\n     * @param path\n     */\n    async remove(path: string): Promise<boolean> {\n        throw new Error(\"bad dispatch to 'remove' (not implemented)\");\n    }\n\n    /**\n     * Returns a new subscribable [[IEvent]] that dispatches whenever changes to the given `path` were\n     * performed. With optional filtering parameters to narrow what to watch\n     *\n     * @param options\n     */\n    async watch(options: IWatchOptions = {}): Promise<IEvent<IWatchEvent>> {\n        throw new Error(\"bad dispatch to 'watch' (not implemented)\");\n    }\n\n    /**\n     * Persists a binary payload to an existing Node.\n     *\n     * > **NOTE**: The [[BaseAdapter.put]] must be called before this method to create a Node\n     *\n     * @param path\n     * @param payload\n     */\n    async write(path: string, payload: Uint8Array): Promise<void> {\n        throw new Error(\"bad dispatch to 'put_payload' (not implemented)\");\n    }\n\n    /**\n     * Returns if the Adapter is currently mounted\n     *\n     * > **NOTE**: There is no base concept of \"mounting\", it could be establishing a connection to a FTP\n     * > server, mounting a local SQLite3 database, etc, etc\n     */\n    is_mounted(): boolean {\n        throw new Error(\"bad dispatch to 'is_mounted' (not implemented)\");\n    }\n\n    /**\n     * Mounts the Adapter if currently unmounted\n     *\n     * > **NOTE**: There is no base concept of \"mounting\", it could be establishing a connection to a FTP\n     * > server, mounting a local SQLite3 database, etc, etc\n     */\n    async mount(): Promise<void> {\n        throw new Error(\"bad dispatch to 'mount' (not implemented)\");\n    }\n\n    /**\n     * Unmounts the Adapter if currently mounted\n     *\n     * > **NOTE**: There is no base concept of \"mounting\", it could be establishing a connection to a FTP\n     * > server, mounting a local SQLite3 database, etc, etc\n     */\n    async unmount(): Promise<void> {\n        throw new Error(\"bad dispatch to 'unmount' (not implemented)\");\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
