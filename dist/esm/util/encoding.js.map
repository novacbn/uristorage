{
  "version": 3,
  "sources": ["../../../src/util/encoding.ts"],
  "sourcesContent": ["// @ts-ignore\nimport {decode as decode_base85, encode as encode_base85} from \"base85\";\n\nimport {ENCODING_MODE} from \"./constants\";\n\n// NOTE: Abstracted for backend / package changes while remaining API-compatible\n\n/**\n * Represents the options passable into [[decode_safe]] / [[encode_safe]]\n */\nexport interface IEncodingOptions {\n    /**\n     * Represents the returned value's encoded type\n     */\n    mode?: ENCODING_MODE;\n}\n\n/**\n * Returns a decoded [ASCII85](https://en.wikipedia.org/wiki/Ascii85 `buffer` into a `string` or `Uint8Array`\n *\n * > **NOTE**: Some Adapters and Overlays can automatically handle encoding for safe storage, so make sure to not double encode\n *\n * @param buffer\n * @param options\n */\nexport function decode_safe(\n    buffer: string | Uint8Array,\n    options?: {mode: ENCODING_MODE.text}\n): string;\nexport function decode_safe(\n    buffer: string | Uint8Array,\n    options?: {mode: ENCODING_MODE.bytes}\n): Uint8Array;\nexport function decode_safe(\n    buffer: Uint8Array | string,\n    options: IEncodingOptions = {}\n): string | Uint8Array {\n    const {mode = ENCODING_MODE.text} = options;\n\n    switch (mode) {\n        case ENCODING_MODE.bytes:\n            return decode_base85(buffer, \"ByteArray\");\n\n        case ENCODING_MODE.text:\n            return decode_base85(buffer, \"String\");\n\n        default:\n            throw new Error(\n                `bad option 'options.mode' to 'decode_safe' (encoding mode '${mode}' not available)`\n            );\n    }\n}\n\n/**\n * Returns the given `buffer` decoded from a UTF-8 encoded `Uint8Array` into a `string`\n * @param buffer\n */\nexport function decode_utf8(buffer: Uint8Array): string {\n    const decoder = new TextDecoder();\n\n    return decoder.decode(buffer);\n}\n\n/**\n * Returns a [ASCII85](https://en.wikipedia.org/wiki/Ascii85 encoded `string` or `Uint8Array` from the given `buffer`\n *\n * > **NOTE**: Some Adapters and Overlays can automatically handle encoding for safe storage, so make sure to not double encode\n *\n * @param buffer\n * @param options\n */\nexport function encode_safe(\n    buffer: string | Uint8Array,\n    options?: {mode: ENCODING_MODE.text}\n): string;\nexport function encode_safe(\n    buffer: string | Uint8Array,\n    options?: {mode: ENCODING_MODE.bytes}\n): Uint8Array;\nexport function encode_safe(\n    buffer: Uint8Array | string,\n    options: IEncodingOptions = {}\n): Uint8Array | string {\n    const {mode = ENCODING_MODE.text} = options;\n\n    switch (mode) {\n        case ENCODING_MODE.bytes:\n            return encode_base85(buffer, \"ByteArray\");\n\n        case ENCODING_MODE.text:\n            return encode_base85(buffer, \"String\");\n\n        default:\n            throw new Error(\n                `bad option 'options.mode' to 'encode_safe' (encoding mode '${mode}' not available)`\n            );\n    }\n}\n\n/**\n * Returns the given `text` into a UTF-8 encoded `Uint8Array`\n * @param text\n */\nexport function encode_utf8(text: string): Uint8Array {\n    const encoder = new TextEncoder();\n\n    return encoder.encode(text);\n}\n"],
  "mappings": "AACA;AAEA;AA8BO,qBACH,kBAC4B;AAE5B,SAAO,OAAO,cAAc,QAAQ;AAEpC,UAAQ;AAAA,SACC,cAAc;AACf,aAAO,cAAc,QAAQ;AAAA,SAE5B,cAAc;AACf,aAAO,cAAc,QAAQ;AAAA;AAG7B,YAAM,IAAI,MACN,8DAA8D;AAAA;AAAA;AASvE;AACH,kBAAgB,IAAI;AAEpB,SAAO,QAAQ,OAAO;AAAA;AAmBnB,uCAEyB;AAE5B,SAAO,OAAO,cAAc,QAAQ;AAEpC,UAAQ;AAAA,SACC,cAAc;AACf,aAAO,cAAc,QAAQ;AAAA,SAE5B,cAAc;AACf,aAAO,cAAc,QAAQ;AAAA;AAG7B,YAAM,IAAI,MACN,8DAA8D;AAAA;AAAA;AASvE;AACH,kBAAgB,IAAI;AAEpB,SAAO,QAAQ,OAAO;AAAA;",
  "names": []
}
