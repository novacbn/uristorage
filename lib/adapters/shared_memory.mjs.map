{
  "version": 3,
  "sources": ["../../src/adapters/shared_memory.ts"],
  "sourcesContent": ["import {compress, decompress} from \"../util/compression\";\nimport {NODE_CHANGES, DEFAULT_MIME_TYPE, NODE_TYPES} from \"../util/constants\";\nimport {get_epoch_timestamp} from \"../util/datetime\";\nimport {IEvent, event} from \"../util/event\";\nimport {ImmutableMap} from \"../util/map\";\nimport {get_mime_type} from \"../util/mime_types\";\n\nimport {\n    IBaseAdapterOptions,\n    INode,\n    IQueryOptions,\n    IQueryResult,\n    IURLObject,\n    IWatchEvent,\n    IWatchOptions,\n    BaseAdapter,\n    create_url_object,\n    filter_query,\n    hook_watcher,\n} from \"./base_adapter\";\n\n/**\n * Represents a persisted Node in a `MemoryAdapter` Adapter\n */\ninterface IMemoryNode extends INode {\n    /**\n     * Represents the binary payload currently stored with the Node\n     */\n    payload?: Uint8Array;\n}\n\n/**\n * Represents the `Map` implementation used for in-memory Node storage\n */\nclass NodeMap extends ImmutableMap<IMemoryNode> {\n    /**\n     * Event that dispatches whenever there is a creation / update in the in-memory storage\n     */\n    EVENT_WATCH = event<IWatchEvent>();\n\n    clone = (node: IMemoryNode): IMemoryNode => {\n        const {ctime, mime_type, mtime, path, type} = node;\n\n        let {payload} = node;\n        if (payload) payload = payload.slice();\n\n        return {ctime, mime_type, mtime, payload, path, type};\n    };\n\n    delete(key: string): boolean {\n        if (this.has(key)) {\n            const node = this.get(key) as IMemoryNode;\n\n            super.delete(key);\n\n            this.EVENT_WATCH.dispatch({\n                change: NODE_CHANGES.removed,\n                path: node.path,\n                type: node.type,\n            });\n\n            return true;\n        }\n\n        return false;\n    }\n\n    put(key: string, value: Omit<IMemoryNode, \"path\">): this {\n        const node: INode = {...value, path: key};\n        super.set(key, node);\n\n        this.EVENT_WATCH.dispatch({\n            change: NODE_CHANGES.created,\n            path: node.path,\n            type: node.type,\n        });\n\n        return this;\n    }\n\n    update(key: string, value: Partial<IMemoryNode>): this {\n        const node = {...this.get(key), ...value, path: key} as IMemoryNode;\n        super.set(key, node);\n\n        if (value.payload) {\n            this.EVENT_WATCH.dispatch({\n                change: NODE_CHANGES.attached,\n                path: node.path,\n                type: node.type,\n            });\n        } else {\n            this.EVENT_WATCH.dispatch({\n                change: NODE_CHANGES.updated,\n                path: node.path,\n                type: node.type,\n            });\n        }\n\n        return this;\n    }\n}\n\n/**\n * Represents the options passable to [[MemoryAdapter]]\n */\nexport interface IMemoryOptions extends IBaseAdapterOptions {\n    /**\n     * Represents if LZ77 Compression should be used for binary payloads for persistence\n     *\n     * > **NOTE**: Depending on the size of the payload and other factors, this can\n     * > incur a CPU performance impact\n     *\n     * > **NOTE**: It's recommended to turn this setting on if persisting large payloads,\n     * > as they as stored in-memory rather than on disk\n     */\n    compressed: boolean;\n}\n\n/**\n * Returns standardized options w/ defaults of [[IMemoryOptions]]\n *\n * @internal\n *\n * @param options\n */\nfunction MemoryOptions(options: Partial<IMemoryOptions> = {}): Partial<IMemoryOptions> {\n    const {compressed = false} = options;\n\n    return {\n        ...options,\n\n        compressed,\n    };\n}\n\n/**\n * Represents a URIStorage Adapter that persists all data into volatile memory\n *\n * > **NOTE**: As this Adapter backend persists data into memory, it is not shared between tabs, pages, nor browsing sessions\n */\nexport class MemoryAdapter extends BaseAdapter {\n    static can_hotlink = true;\n\n    static can_watch = true;\n\n    static is_available = true;\n\n    /**\n     * Represents the in-memory storage for Nodes\n     */\n    storage = new NodeMap();\n\n    options!: IMemoryOptions;\n\n    constructor(options: Partial<IMemoryOptions> = {}) {\n        super(MemoryOptions(options));\n    }\n\n    async create_url_object(path: string): Promise<IURLObject> {\n        const {storage} = this;\n        const {compressed} = this.options;\n\n        const uri = this.normalize(path);\n        if (!storage.has(uri)) {\n            throw new Error(\n                \"bad argument #0 to 'create_url_object' (Node must be created before using 'create_url_object')\"\n            );\n        }\n\n        const node = storage.get(uri) as IMemoryNode;\n        if (!node.payload) {\n            throw new Error(\n                \"bad argument #0 to 'create_url_object' (Node payload must be created before using 'create_url_object')\"\n            );\n        }\n\n        const payload = compressed ? decompress(node.payload) : node.payload;\n        const object = create_url_object(payload, node.mime_type);\n\n        return {\n            destroy: object.destroy,\n            path: node.path,\n            url: object.url,\n        };\n    }\n\n    async get(path: string): Promise<INode | null> {\n        const {storage} = this;\n\n        const uri = this.normalize(path);\n        if (!storage.has(uri)) return null;\n\n        const node = storage.get(uri) as IMemoryNode;\n\n        return {\n            ctime: node.ctime,\n            mime_type: node.mime_type,\n            mtime: node.mtime,\n            path: node.path,\n            type: node.type,\n        };\n    }\n\n    /**\n     * Persists a new or updates an existing Node with new metadata. Optionally can specify the Node's [[NODE_TYPES]]\n     *\n     * > **NOTE**: Will try to guess the Mime Type if `mime_type` is `undefined`\n     *\n     * @param path\n     * @param type\n     * @param mime_type\n     */\n    async put(\n        path: string,\n        type: NODE_TYPES = NODE_TYPES.undefined,\n        mime_type?: string\n    ): Promise<void> {\n        const {storage} = this;\n\n        const uri = this.normalize(path);\n\n        const timestamp = get_epoch_timestamp();\n        if (!mime_type) mime_type = get_mime_type(uri) || DEFAULT_MIME_TYPE;\n\n        if (storage.has(uri)) {\n            storage.update(uri, {\n                mime_type,\n                mtime: timestamp,\n                type,\n            });\n        } else {\n            storage.put(uri, {\n                ctime: timestamp,\n                mime_type,\n                mtime: timestamp,\n                type,\n            });\n        }\n    }\n\n    async query(options: IQueryOptions = {}): Promise<IQueryResult[]> {\n        const entries = Array.from(this.storage.entries());\n\n        const nodes = entries.map((entry, index) => {\n            const path = entry[0];\n            const {type = NODE_TYPES.undefined} = entry[1];\n\n            return {path, type};\n        });\n\n        return filter_query(nodes, options);\n    }\n\n    async read(path: string): Promise<Uint8Array | null> {\n        const {storage} = this;\n        const {compressed} = this.options;\n\n        const uri = this.normalize(path);\n        if (!storage.has(uri)) return null;\n\n        const node = storage.get(uri) as IMemoryNode;\n        if (!node.payload) return null;\n\n        return compressed ? decompress(node.payload) : node.payload;\n    }\n\n    async remove(path: string): Promise<boolean> {\n        const {storage} = this;\n\n        const uri = this.normalize(path);\n        return storage.delete(uri);\n    }\n\n    async watch(options: IWatchOptions = {}): Promise<IEvent<IWatchEvent>> {\n        return hook_watcher(this.storage.EVENT_WATCH, options);\n    }\n\n    async write(path: string, payload: Uint8Array): Promise<void> {\n        const {storage} = this;\n        const {compressed} = this.options;\n\n        const uri = this.normalize(path);\n        if (!storage.has(uri)) {\n            throw new Error(\n                \"bad argument #0 to 'attach' (Node must be created before using 'attach')\"\n            );\n        }\n\n        storage.update(uri, {\n            mtime: get_epoch_timestamp(),\n            payload: compressed ? compress(payload) : payload,\n        });\n    }\n\n    /**\n     * Returns if the Adapter is currently mounted\n     *\n     * > **NOTE**: `MemoryAdapter`-based Adapters are **ALWAYS** mounted\n     */\n    is_mounted(): boolean {\n        return true;\n    }\n\n    /**\n     * Mounts the Adapter if currently unmounted\n     *\n     * > **NOTE**: `MemoryAdapter`-based Adapters are **ALWAYS** mounted\n     */\n    async mount(): Promise<void> {}\n\n    /**\n     * Mounts the Adapter if currently mounted\n     *\n     * > **NOTE**: `MemoryAdapter`-based Adapters are **ALWAYS** mounted\n     */\n    async unmount(): Promise<void> {}\n}\n"],
  "mappings": "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",
  "names": []
}
