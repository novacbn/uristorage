{
  "version": 3,
  "sources": ["src/storage_registry.ts"],
  "sourcesContent": ["import {BaseAdapter} from \"./adapters/base_adapter\";\nimport {BaseOverlay} from \"./overlays/base_overlay\";\n\nimport {event} from \"./util/event\";\nimport {ImmutableMap} from \"./util/map\";\n\n// TODO: Documentation\n\nexport type IStorage = BaseAdapter | BaseOverlay;\n\nexport interface IRegistryNode<T extends IStorage> {\n    storage: T;\n}\n\nexport interface IRegistryResolveResult {\n    namespace: string;\n\n    path: string;\n}\n\nexport interface IRegistryMountEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\nexport interface IRegistryRegisterEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\nexport class StorageRegistry<\n    T extends IStorage = IStorage,\n    V extends IRegistryNode<T> = IRegistryNode<T>\n> extends ImmutableMap<V> {\n    EVENT_MOUNTED = event<IRegistryMountEvent<T>>();\n\n    EVENT_REGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    EVENT_UNMOUNTED = event<IRegistryMountEvent<T>>();\n\n    EVENT_UNREGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    constructor() {\n        super();\n    }\n\n    clone = (node: V): any => {\n        const {storage} = node;\n\n        return {storage};\n    };\n\n    clear(): void {\n        const nodes = this.entries();\n        for (const [namespace, node] of nodes) {\n            const {storage} = node;\n\n            this.EVENT_UNREGISTERED.dispatch({namespace, storage});\n        }\n\n        super.clear();\n    }\n\n    delete(namespace: string): boolean {\n        const node = this.get(namespace);\n        const deleted = super.delete(namespace);\n\n        if (deleted && node) {\n            this.EVENT_UNREGISTERED.dispatch({namespace, storage: node.storage});\n        }\n\n        return deleted;\n    }\n\n    resolve(uri: string): (V & IRegistryResolveResult) | undefined {\n        let url: URL;\n        try {\n            url = new URL(uri);\n        } catch (err) {\n            return undefined;\n        }\n\n        const namespace = url.protocol.slice(0, -1);\n        const node = this.get(namespace);\n        if (!node) return undefined;\n\n        return {...node, namespace, path: url.pathname};\n    }\n\n    set(namespace: string, node: V): this {\n        const {storage} = node;\n        super.set(namespace, {...node, namespace});\n\n        storage.EVENT_MOUNTED.subscribe(() => this.EVENT_MOUNTED.dispatch({namespace, storage}));\n\n        storage.EVENT_UNMOUNTED.subscribe(() =>\n            this.EVENT_UNMOUNTED.dispatch({namespace, storage})\n        );\n\n        this.EVENT_REGISTERED.dispatch({namespace, storage});\n        return this;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAGA,cAAoB;AACpB,YAA2B;AAJ3B,8BAmCU;AAAA,EASN;AACI;AATJ,yBAAgB;AAEhB,4BAAmB;AAEnB,2BAAkB;AAElB,8BAAqB;AAMrB,iBAAQ,CAAC;AACL,YAAM,CAAC,WAAW;AAElB,aAAO,CAAC;AAAA;AAAA;AAAA,EAGZ;AACI,UAAM,QAAQ,KAAK;AACnB,eAAW,CAAC,WAAW,SAAS;AAC5B,YAAM,CAAC,WAAW;AAElB,WAAK,mBAAmB,SAAS,CAAC,WAAW;AAAA;AAGjD,UAAM;AAAA;AAAA,EAGV,OAAO;AACH,UAAM,OAAO,KAAK,IAAI;AACtB,UAAM,UAAU,MAAM,OAAO;AAE7B,QAAI,WAAW;AACX,WAAK,mBAAmB,SAAS,CAAC,WAAW,SAAS,KAAK;AAAA;AAG/D,WAAO;AAAA;AAAA,EAGX,QAAQ;AACJ,QAAI;AACJ;AACI,YAAM,IAAI,IAAI;AAAA,aACT;AACL,aAAO;AAAA;AAGX,UAAM,YAAY,IAAI,SAAS,MAAM,GAAG;AACxC,UAAM,OAAO,KAAK,IAAI;AACtB,QAAI,CAAC;AAAM,aAAO;AAElB,WAAO,IAAI,MAAM,WAAW,MAAM,IAAI;AAAA;AAAA,EAG1C,IAAI,WAAmB;AACnB,UAAM,CAAC,WAAW;AAClB,UAAM,IAAI,WAAW,IAAI,MAAM;AAE/B,YAAQ,cAAc,UAAU,MAAM,KAAK,cAAc,SAAS,CAAC,WAAW;AAE9E,YAAQ,gBAAgB,UAAU,MAC9B,KAAK,gBAAgB,SAAS,CAAC,WAAW;AAG9C,SAAK,iBAAiB,SAAS,CAAC,WAAW;AAC3C,WAAO;AAAA;AAAA;",
  "names": []
}
