{
  "version": 3,
  "sources": ["src/util/compression.ts"],
  "sourcesContent": ["import {compress as compress_lz, decompress as decompress_lz} from \"lzutf8\";\n\nimport {ENCODING_MODE} from \"./constants\";\n\n// NOTE: Abstracted for backend / package changes while remaining API-compatible\n\n/**\n * Represents the options passable into [[compress]] / [[decompress]]\n */\nexport interface ICompressionOptions {\n    /**\n     * Represents the returned value's encoded type\n     */\n    mode?: ENCODING_MODE;\n}\n\n/**\n * Returns the `buffer` compressed via LZ77 Compression\n *\n * > **NOTE**: Only [[ENCODING_MODE.bytes]] supports for [[ICompressionOptions.mode]]\n *\n * > **NOTE**: Some Adapters and Overlays can automatically handle compression, so make sure to not double compress\n *\n * @param buffer\n * @param options\n */\nexport function compress(\n    buffer: string | Uint8Array,\n    options: ICompressionOptions = {}\n): Uint8Array {\n    const {mode = ENCODING_MODE.bytes} = options;\n\n    switch (mode) {\n        case ENCODING_MODE.bytes:\n            return compress_lz(buffer, {outputEncoding: \"ByteArray\"});\n\n        default:\n            throw new Error(\n                `bad option 'options.mode' to 'compress' (encoding mode '${mode}' not available)`\n            );\n    }\n}\n\n/**\n * Returns the `buffer` decompressed, via LZ77 Compression, into a `string` or `Uint8Array`\n *\n * > **NOTE**: Some Adapters and Overlays can automatically handle compression, so make sure to not double compress\n *\n * @param buffer\n * @param options\n */\nexport function decompress(\n    buffer: string | Uint8Array,\n    options?: {mode: ENCODING_MODE.bytes}\n): Uint8Array;\nexport function decompress(\n    buffer: string | Uint8Array,\n    options?: {mode: ENCODING_MODE.text}\n): string;\nexport function decompress(\n    buffer: string | Uint8Array,\n    options: ICompressionOptions = {}\n): string | Uint8Array {\n    const {mode = ENCODING_MODE.bytes} = options;\n\n    switch (mode) {\n        case ENCODING_MODE.bytes:\n            return decompress_lz(buffer, {outputEncoding: \"ByteArray\"});\n\n        case ENCODING_MODE.text:\n            return decompress_lz(buffer, {outputEncoding: \"String\"});\n\n        default:\n            throw new Error(\n                `bad option 'options.mode' to 'decompress' (encoding mode '${mode}' not available)`\n            );\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,eAAmE;AAEnE,kBAA4B;AAwBrB,kBACH,QACA,UAA+B;AAE/B,QAAM,CAAC,OAAO,wBAAc,SAAS;AAErC,UAAQ;AAAA,SACC,wBAAc;AACf,aAAO,gBAAY,QAAQ,CAAC,gBAAgB;AAAA;AAG5C,YAAM,IAAI,MACN,2DAA2D;AAAA;AAAA;AAqBpE,oBACH,QACA,UAA+B;AAE/B,QAAM,CAAC,OAAO,wBAAc,SAAS;AAErC,UAAQ;AAAA,SACC,wBAAc;AACf,aAAO,kBAAc,QAAQ,CAAC,gBAAgB;AAAA,SAE7C,wBAAc;AACf,aAAO,kBAAc,QAAQ,CAAC,gBAAgB;AAAA;AAG9C,YAAM,IAAI,MACN,6DAA6D;AAAA;AAAA;",
  "names": []
}
