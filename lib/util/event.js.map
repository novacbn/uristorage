{
  "version": 3,
  "sources": ["src/util/event.ts"],
  "sourcesContent": ["/**\n * Represents the callback supplied by subscribers to be called every dispatch\n */\nexport type IEventCallback<T> = (value: T) => void;\n\n/**\n * Represents the notification subscription used whenever a first subscription is added\n */\nexport type IEventNotifier<T> = (dispatch: IEventCallback<T>) => IEventUnsubscriber;\n\n/**\n * Represents the unsubscribe function returned by [[IEvent.subscribe]]\n */\nexport type IEventUnsubscriber = () => void;\n\n/**\n * Represents the tuple that internally represents a subscription\n */\ntype IEventSubscriber<T> = [IEventCallback<T>];\n\n/**\n * Represents an interface to publish event data via a singleton instance, that is compatible with Svelte Store subscriptions\n */\nexport interface IEvent<T> {\n    /**\n     * Dispatches new event details to every subscriber\n     * @param details\n     */\n    dispatch(details: T): void;\n\n    /**\n     * Subscribes to new incoming event dispatches\n     * @param run\n     */\n    subscribe(run: IEventCallback<T>): IEventUnsubscriber;\n}\n\n/**\n * Returns a new [[IEvent]] instance, for handling event publishing in non-DOM related contexts\n *\n * @internal\n *\n * @param start\n */\nexport function event<T>(start?: IEventNotifier<T>): IEvent<T> {\n    const subscribers: IEventSubscriber<T>[] = [];\n\n    let stop: IEventUnsubscriber | null;\n\n    const dispatch = (details: T) => {\n        if (subscribers.length > 0) {\n            for (let index = 0; index < subscribers.length; index++) {\n                const [run] = subscribers[index];\n\n                run(details);\n            }\n        }\n    };\n\n    const subscribe = (run: IEventCallback<T>) => {\n        const subscriber: IEventSubscriber<T> = [run];\n\n        subscribers.push(subscriber);\n        if (start && subscribers.length === 1) stop = start(dispatch);\n\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index > 0) {\n                subscribers.splice(index, 1);\n\n                if (stop && subscribers.length == 0) {\n                    stop();\n                    stop = null;\n                }\n            }\n        };\n    };\n\n    return {dispatch, subscribe};\n}\n"],
  "mappings": ";;;;;;;;;AAAA;AAAA;AAAA;AA4CO,eAAkB;AACrB,QAAM,cAAqC;AAE3C,MAAI;AAEJ,QAAM,WAAW,CAAC;AACd,QAAI,YAAY,SAAS;AACrB,eAAS,QAAQ,GAAG,QAAQ,YAAY,QAAQ;AAC5C,cAAM,CAAC,OAAO,YAAY;AAE1B,YAAI;AAAA;AAAA;AAAA;AAKhB,QAAM,YAAY,CAAC;AACf,UAAM,aAAkC,CAAC;AAEzC,gBAAY,KAAK;AACjB,QAAI,SAAS,YAAY,WAAW;AAAG,aAAO,MAAM;AAEpD,WAAO;AACH,YAAM,QAAQ,YAAY,QAAQ;AAClC,UAAI,QAAQ;AACR,oBAAY,OAAO,OAAO;AAE1B,YAAI,QAAQ,YAAY,UAAU;AAC9B;AACA,iBAAO;AAAA;AAAA;AAAA;AAAA;AAMvB,SAAO,CAAC,UAAU;AAAA;",
  "names": []
}
