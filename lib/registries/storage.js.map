{
  "version": 3,
  "sources": ["../../src/registries/storage.ts", "../../src/registries/storage.ts"],
  "sourcesContent": ["import {BaseAdapter} from \"../adapters/base_adapter\";\nimport {BaseOverlay} from \"../overlays/base_overlay\";\n\nimport {event} from \"../util/event\";\nimport {ImmutableMap} from \"../util/map\";\nimport {REGEX_TRAILING_SLASH, normalize} from \"../util/path\";\n\n/**\n * Represents instance types acceptable to be registered with a [[StorageRegistry]]\n * instance\n */\nexport type IStorage = BaseAdapter | BaseOverlay;\n\n/**\n * Represents a Node that contains information about a registered [[IStorage]] instance\n */\nexport interface IRegistryNode<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\n/**\n * Represents the extra metadata returned from [[StorageRegistry.resolve]]\n */\nexport interface IRegistryResolveResult {\n    path: string;\n}\n\n/**\n * Represents the event details dispatched to subscribers via [[StorageRegistry.EVENT_MOUNTED]] / [[StorageRegistry.EVENT_UNMOUNTED]]\n */\nexport interface IRegistryMountEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\n/**\n * Represents the event details dispatched to subscribers via [[StorageRegistry.EVENT_REGISTERED]] / [[StorageRegistry.EVENT_UNREGISTERED]]\n */\nexport interface IRegistryRegisterEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\n/**\n * ...\n *\n * @internal\n *\n * @param url\n */\nfunction get_namespace(url: URL): string {\n    const {protocol} = url;\n\n    return protocol.replace(REGEX_TRAILING_SLASH, \"\").slice(0, -1);\n}\n\n/**\n * ...\n *\n * @internal\n *\n * @param url\n */\nfunction get_path(url: URL): string {\n    const {pathname} = url;\n\n    return normalize(pathname);\n}\n\n/**\n * Represents the base common API all storage registries implement. Accepting instances\n * of [[BaseAdapter]] or [[BaseOverlay]] for registeration and lookup\n */\nexport class StorageRegistry<\n    T extends IStorage = IStorage,\n    V extends IRegistryNode<T> = IRegistryNode<T>\n> extends ImmutableMap<V> {\n    /**\n     * Event that dispatches whenever a registered [[IStorage]] instance is mounted\n     */\n    EVENT_MOUNTED = event<IRegistryMountEvent<T>>();\n\n    /**\n     * Event that dispatches whenever a new [[IStorage]] instance is registered\n     */\n    EVENT_REGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    /**\n     * Event that dispatches whenever a registered [[IStorage]] instance is unmounted\n     */\n    EVENT_UNMOUNTED = event<IRegistryMountEvent<T>>();\n\n    /**\n     * Event that dispatches whenever a new [[IStorage]] instance is unregistered\n     */\n    EVENT_UNREGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    constructor() {\n        super();\n    }\n\n    /**\n     * ...\n     *\n     * @internal\n     *\n     * @param node\n     */\n    clone = (node: V): V => {\n        const {namespace, storage} = node;\n\n        return {namespace, storage} as V;\n    };\n\n    clear(): void {\n        const nodes = this.entries();\n        for (const [namespace, node] of nodes) {\n            const {storage} = node;\n\n            this.EVENT_UNREGISTERED.dispatch({namespace, storage});\n        }\n\n        super.clear();\n    }\n\n    /**\n     * Registers an [[BaseAdapter]] or [[BaseOverlay]] instance with the Registry\n     * @param namespace\n     * @param storage\n     */\n    register(namespace: string, storage: T): this | Promise<this> {\n        if (this.has(namespace)) {\n            throw new Error(\n                `bad argument #0 to 'register' (namespace '${namespace}' already registered)`\n            );\n        }\n\n        // @ts-ignore\n        const node: V = {namespace, storage};\n        this.set(namespace, node);\n\n        storage.EVENT_MOUNTED.subscribe(() => this.EVENT_MOUNTED.dispatch({namespace, storage}));\n        storage.EVENT_UNMOUNTED.subscribe(() =>\n            this.EVENT_UNMOUNTED.dispatch({namespace, storage})\n        );\n\n        this.EVENT_REGISTERED.dispatch({namespace, storage});\n        return this;\n    }\n\n    /**\n     * Unregisters a previously [[BaseAdapter]] or [[BaseOverlay]] instance from the Registry\n     * @param namespace\n     * @param storage\n     */\n    unregister(namespace: string): this | Promise<this> {\n        const node = this.get(namespace);\n        if (!node) {\n            throw new Error(\n                `bad argument #0 to 'unregister' (namespace '${namespace}' not registered)`\n            );\n        }\n\n        this.delete(namespace);\n        this.EVENT_UNREGISTERED.dispatch({namespace, storage: node.storage});\n        return this;\n    }\n\n    /**\n     * Returns the resolved namespace and path of a registered [[BaseAdapter]] or [[BaseOverlay]] instance,\n     * returning `null` if none found or the URI could not be parsed\n     * @param uri\n     */\n    resolve(uri: string | URL): (V & IRegistryResolveResult) | null {\n        if (typeof uri === \"string\") {\n            try {\n                uri = new URL(uri);\n            } catch (err) {\n                return null;\n            }\n        }\n\n        const namespace = get_namespace(uri);\n        const path = get_path(uri);\n\n        const node = this.get(namespace);\n        if (!node) return null;\n\n        return {...node, path};\n    }\n}\n", "import {BaseAdapter} from \"../adapters/base_adapter\";\nimport {BaseOverlay} from \"../overlays/base_overlay\";\n\nimport {event} from \"../util/event\";\nimport {ImmutableMap} from \"../util/map\";\nimport {REGEX_TRAILING_SLASH, normalize} from \"../util/path\";\n\n/**\n * Represents instance types acceptable to be registered with a [[StorageRegistry]]\n * instance\n */\nexport type IStorage = BaseAdapter | BaseOverlay;\n\n/**\n * Represents a Node that contains information about a registered [[IStorage]] instance\n */\nexport interface IRegistryNode<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\n/**\n * Represents the extra metadata returned from [[StorageRegistry.resolve]]\n */\nexport interface IRegistryResolveResult {\n    path: string;\n}\n\n/**\n * Represents the event details dispatched to subscribers via [[StorageRegistry.EVENT_MOUNTED]] / [[StorageRegistry.EVENT_UNMOUNTED]]\n */\nexport interface IRegistryMountEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\n/**\n * Represents the event details dispatched to subscribers via [[StorageRegistry.EVENT_REGISTERED]] / [[StorageRegistry.EVENT_UNREGISTERED]]\n */\nexport interface IRegistryRegisterEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\n/**\n * ...\n *\n * @internal\n *\n * @param url\n */\nfunction get_namespace(url: URL): string {\n    const {protocol} = url;\n\n    return protocol.replace(REGEX_TRAILING_SLASH, \"\").slice(0, -1);\n}\n\n/**\n * ...\n *\n * @internal\n *\n * @param url\n */\nfunction get_path(url: URL): string {\n    const {pathname} = url;\n\n    return normalize(pathname);\n}\n\n/**\n * Represents the base common API all storage registries implement. Accepting instances\n * of [[BaseAdapter]] or [[BaseOverlay]] for registeration and lookup\n */\nexport class StorageRegistry<\n    T extends IStorage = IStorage,\n    V extends IRegistryNode<T> = IRegistryNode<T>\n> extends ImmutableMap<V> {\n    /**\n     * Event that dispatches whenever a registered [[IStorage]] instance is mounted\n     */\n    EVENT_MOUNTED = event<IRegistryMountEvent<T>>();\n\n    /**\n     * Event that dispatches whenever a new [[IStorage]] instance is registered\n     */\n    EVENT_REGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    /**\n     * Event that dispatches whenever a registered [[IStorage]] instance is unmounted\n     */\n    EVENT_UNMOUNTED = event<IRegistryMountEvent<T>>();\n\n    /**\n     * Event that dispatches whenever a new [[IStorage]] instance is unregistered\n     */\n    EVENT_UNREGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    constructor() {\n        super();\n    }\n\n    /**\n     * ...\n     *\n     * @internal\n     *\n     * @param node\n     */\n    clone = (node: V): V => {\n        const {namespace, storage} = node;\n\n        return {namespace, storage} as V;\n    };\n\n    clear(): void {\n        const nodes = this.entries();\n        for (const [namespace, node] of nodes) {\n            const {storage} = node;\n\n            this.EVENT_UNREGISTERED.dispatch({namespace, storage});\n        }\n\n        super.clear();\n    }\n\n    /**\n     * Registers an [[BaseAdapter]] or [[BaseOverlay]] instance with the Registry\n     * @param namespace\n     * @param storage\n     */\n    register(namespace: string, storage: T): this | Promise<this> {\n        if (this.has(namespace)) {\n            throw new Error(\n                `bad argument #0 to 'register' (namespace '${namespace}' already registered)`\n            );\n        }\n\n        // @ts-ignore\n        const node: V = {namespace, storage};\n        this.set(namespace, node);\n\n        storage.EVENT_MOUNTED.subscribe(() => this.EVENT_MOUNTED.dispatch({namespace, storage}));\n        storage.EVENT_UNMOUNTED.subscribe(() =>\n            this.EVENT_UNMOUNTED.dispatch({namespace, storage})\n        );\n\n        this.EVENT_REGISTERED.dispatch({namespace, storage});\n        return this;\n    }\n\n    /**\n     * Unregisters a previously [[BaseAdapter]] or [[BaseOverlay]] instance from the Registry\n     * @param namespace\n     * @param storage\n     */\n    unregister(namespace: string): this | Promise<this> {\n        const node = this.get(namespace);\n        if (!node) {\n            throw new Error(\n                `bad argument #0 to 'unregister' (namespace '${namespace}' not registered)`\n            );\n        }\n\n        this.delete(namespace);\n        this.EVENT_UNREGISTERED.dispatch({namespace, storage: node.storage});\n        return this;\n    }\n\n    /**\n     * Returns the resolved namespace and path of a registered [[BaseAdapter]] or [[BaseOverlay]] instance,\n     * returning `null` if none found or the URI could not be parsed\n     * @param uri\n     */\n    resolve(uri: string | URL): (V & IRegistryResolveResult) | null {\n        if (typeof uri === \"string\") {\n            try {\n                uri = new URL(uri);\n            } catch (err) {\n                return null;\n            }\n        }\n\n        const namespace = get_namespace(uri);\n        const path = get_path(uri);\n\n        const node = this.get(namespace);\n        if (!node) return null;\n\n        return {...node, path};\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;ACGA,MAAA,QAAoB;AACpB,YAA2B;AAC3B,aAA8C;AAiD9C;AACI,SAAO,YAAY;AAEnB,SAAO,SAAS,QAAQ,2BAAsB,IAAI,MAAM,GAAG;AAAA;AAU/D;AACI,SAAO,YAAY;AAEnB,SAAO,eAAU;AAAA;AAtErB,8BAgFU;AAAA,EAqBN;AACI;AAlBJ,yBAAgB;AAKhB,4BAAmB;AAKnB,2BAAkB;AAKlB,8BAAqB;AAarB,iBAAQ;AACJ,aAAO,WAAW,WAAW;AAE7B,aAAO,CAAC,WAAW;AAAA;AAAA;AAAA,EAGvB;AACI,kBAAc,KAAK;AACnB,oCAAgC;AAC5B,aAAO,WAAW;AAElB,WAAK,mBAAmB,SAAS,CAAC,WAAW;AAAA;AAGjD,UAAM;AAAA;AAAA,EAQV;AACI,QAAI,KAAK,IAAI;AACT,YAAM,IAAI,MACN,6CAA6C;AAAA;AAKrD,iBAAgB,CAAC,WAAW;AAC5B,SAAK,IAAI,WAAW;AAEpB,YAAQ,cAAc,UAAU,MAAM,KAAK,cAAc,SAAS,CAAC,WAAW;AAC9E,YAAQ,gBAAgB,UAAU,MAC9B,KAAK,gBAAgB,SAAS,CAAC,WAAW;AAG9C,SAAK,iBAAiB,SAAS,CAAC,WAAW;AAC3C,WAAO;AAAA;AAAA,EAQX;AACI,iBAAa,KAAK,IAAI;AACtB,QAAI,CAAC;AACD,YAAM,IAAI,MACN,+CAA+C;AAAA;AAIvD,SAAK,OAAO;AACZ,SAAK,mBAAmB,SAAS,CAAC,WAAW,SAAS,KAAK;AAC3D,WAAO;AAAA;AAAA,EAQX;AACI,QAAI,OAAO,QAAQ;AACf;AACI,cAAM,IAAI,IAAI;AAAA;AAEd,eAAO;AAAA;AAAA;AAIf,sBAAkB,cAAc;AAChC,kBAAa,SAAS;AAEtB,iBAAa,KAAK,IAAI;AACtB,QAAI,CAAC;AAAM,aAAO;AAElB,WAAO,IAAI,MAAM;AAAA;AAAA;",
  "names": []
}
