{
  "version": 3,
  "sources": ["../../src/registries/file_system.ts"],
  "sourcesContent": ["import type {IURLObject} from \"../adapters\";\n\nimport type {\n    IFileSystemEntryResult,\n    IFileSystemEntryStats,\n    IFileSystemQueryOptions,\n    IFileSystemRemoveOptions,\n    IFileSystemWatchEvent,\n    IFileSystemWatchOptions,\n} from \"../overlays/file_system\";\nimport {FileSystemOverlay} from \"../overlays/file_system\";\n\nimport type {IEvent} from \"../util/event\";\n\nimport type {IJSONReplacer, IJSONReviver, IJSONValue} from \"../util/types\";\n\nimport type {IRegistryNode} from \"./storage\";\nimport {StorageRegistry} from \"./storage\";\n\n/**\n * Represents a Node that contains information about a registered [[FileSystemOverlay]] instance\n */\nexport interface IFileSystemRegistryNode extends IRegistryNode<FileSystemOverlay> {}\n\n/**\n * Represents a [[StorageRegistry]] that mimics the API of a [[FileSystemOverlay]] instance, resolving all\n * path-based operations via URI (`my-namespace://path/to/file.txt`) parsing. Using the URI protocol as the\n * namespace to lookup, and the URI pathname as the directory / file path\n */\nexport class FileSystemRegistry extends StorageRegistry<\n    FileSystemOverlay,\n    IFileSystemRegistryNode\n> {\n    /**\n     * ...\n     *\n     * @internal\n     *\n     * @param node\n     */\n    clone = (node: IFileSystemRegistryNode): IFileSystemRegistryNode => {\n        const {namespace, storage} = node;\n\n        return {namespace, storage};\n    };\n\n    /**\n     * Returns a embedable URL representing a File in the File System\n     *\n     * > **NOTE**: Will not work with if the configured Adapter's [[BaseAdapter.can_hotlink]] is `false`\n     *\n     * @param uri\n     */\n    create_url_object(uri: string): Promise<IURLObject> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'create_url_object' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.create_url_object(path);\n    }\n\n    /**\n     * Creates a new Directory in the File System\n     * @param uri\n     */\n    create_directory(uri: string): Promise<void> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'create_directory' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.create_directory(path);\n    }\n\n    /**\n     * Returns if a given Entry exists on the File System\n     * @param uri\n     */\n    exists(uri: string): Promise<boolean> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'exists' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.exists(path);\n    }\n\n    /**\n     * Returns the File System metadata about a given Entry\n     * @param uri\n     */\n    get_stats(uri: string): Promise<IFileSystemEntryStats> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'get_stats' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.get_stats(path);\n    }\n\n    /**\n     * Returns entries queried from the File System, with optional filters\n     * @param namespace\n     * @param options\n     */\n    read_directory(\n        namespace: string,\n        options: IFileSystemQueryOptions = {}\n    ): Promise<IFileSystemEntryResult[]> {\n        const node = this.get(namespace);\n        if (!node) {\n            throw new Error(\n                `bad argument #0 to 'read_directory' (could not resolve '${namespace}')`\n            );\n        }\n\n        const {storage} = node;\n        return storage.read_directory(options);\n    }\n\n    /**\n     * Returns a `Uint8Array` a File in the File System\n     * @param uri\n     */\n    read_file(uri: string): Promise<Uint8Array> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'read_file' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.read_file(path);\n    }\n\n    /**\n     * Removes a Directory from the File System\n     *\n     * > **NOTE**: If [[IFileSystemRemoveOptions.recursive]] to `false`, the dispatch will fail if sub-paths are found\n     *\n     * @param uri\n     * @param options\n     */\n    remove_directory(uri: string, options: IFileSystemRemoveOptions = {}): Promise<boolean> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'remove_directory' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.remove_directory(path, options);\n    }\n\n    /**\n     * Removes a File from the File System\n     * @param uri\n     */\n    remove_file(uri: string): Promise<void> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'remove_file' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.remove_file(path);\n    }\n\n    /**\n     * Watches a Directory for any changes on the File System\n     * @param uri\n     */\n    watch_directory(\n        uri: string,\n        options: IFileSystemWatchOptions = {}\n    ): Promise<IEvent<IFileSystemWatchEvent>> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'watch_directory' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.watch_directory(path, options);\n    }\n\n    /**\n     * Watches a File for any changes on the File System\n     * @param uri\n     */\n    watch_file(uri: string): Promise<IEvent<IFileSystemWatchEvent>> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'watch_file' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.watch_file(path);\n    }\n\n    /**\n     * Writes a `Uint8Array` payload to a File. Creating a new File in the File System, if not previously made\n     * @param uri\n     * @param payload\n     */\n    write_file(uri: string, payload: Uint8Array): Promise<void> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'write_file' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.write_file(path, payload);\n    }\n\n    /**\n     * Returns parsed JSON read from the given `uri`\n     * @param uri\n     * @param reviver\n     */\n    read_file_json<T extends IJSONValue = IJSONValue>(\n        uri: string,\n        reviver?: IJSONReviver\n    ): Promise<T> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'read_file_json' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.read_file_json(path, reviver);\n    }\n\n    /**\n     * Returns UTF-8 text read from the given `uri`\n     * @param uri\n     */\n    read_file_text(uri: string): Promise<string> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'read_file_text' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.read_file_text(path);\n    }\n\n    /**\n     * Writes to the given `uri`, encoding `value` as JSON text\n     * @param uri\n     * @param value\n     * @param replacer\n     * @param space\n     */\n    write_file_json<T extends IJSONValue = IJSONValue>(\n        uri: string,\n        value: T,\n        replacer?: IJSONReplacer,\n        space?: number | string\n    ): Promise<void> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'write_file_json' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.write_file_json(path, value, replacer, space);\n    }\n\n    /**\n     * Writes to the given `uri`, encoding `text` as UTF-8 bytes\n     * @param uri\n     * @param text\n     */\n    write_file_text(uri: string, text: string): Promise<void> {\n        const result = this.resolve(uri);\n        if (!result) {\n            throw new Error(`bad argument #0 to 'write_file_text' (could not resolve '${uri}')`);\n        }\n\n        const {path, storage} = result;\n        return storage.write_file_text(path, text);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
