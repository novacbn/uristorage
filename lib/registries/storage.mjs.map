{
  "version": 3,
  "sources": ["../../src/registries/storage.ts"],
  "sourcesContent": ["import {BaseAdapter} from \"../adapters/base_adapter\";\nimport {BaseOverlay} from \"../overlays/base_overlay\";\n\nimport {event} from \"../util/event\";\nimport {ImmutableMap} from \"../util/map\";\n\n// TODO: Documentation\n\nexport type IStorage = BaseAdapter | BaseOverlay;\n\nexport interface IRegistryNode<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\nexport interface IRegistryResolveResult {\n    path: string;\n}\n\nexport interface IRegistryMountEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\nexport interface IRegistryRegisterEvent<T extends IStorage> {\n    namespace: string;\n\n    storage: T;\n}\n\nexport class StorageRegistry<\n    T extends IStorage = IStorage,\n    V extends IRegistryNode<T> = IRegistryNode<T>\n> extends ImmutableMap<V> {\n    EVENT_MOUNTED = event<IRegistryMountEvent<T>>();\n\n    EVENT_REGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    EVENT_UNMOUNTED = event<IRegistryMountEvent<T>>();\n\n    EVENT_UNREGISTERED = event<IRegistryRegisterEvent<T>>();\n\n    constructor() {\n        super();\n    }\n\n    clone = (node: V): any => {\n        const {namespace, storage} = node;\n\n        return {namespace, storage};\n    };\n\n    clear(): void {\n        const nodes = this.entries();\n        for (const [namespace, node] of nodes) {\n            const {storage} = node;\n\n            this.EVENT_UNREGISTERED.dispatch({namespace, storage});\n        }\n\n        super.clear();\n    }\n\n    register(namespace: string, storage: T): this | Promise<this> {\n        if (this.has(namespace)) {\n            throw new Error(\n                `bad argument #0 to 'register' (namespace '${namespace}' already registered)`\n            );\n        }\n\n        // @ts-ignore\n        const node: V = {namespace, storage};\n        super.set(namespace, node);\n\n        storage.EVENT_MOUNTED.subscribe(() => this.EVENT_MOUNTED.dispatch({namespace, storage}));\n        storage.EVENT_UNMOUNTED.subscribe(() =>\n            this.EVENT_UNMOUNTED.dispatch({namespace, storage})\n        );\n\n        this.EVENT_REGISTERED.dispatch({namespace, storage});\n        return this;\n    }\n\n    unregister(namespace: string): this | Promise<this> {\n        const node = this.get(namespace);\n        if (!node) {\n            throw new Error(\n                `bad argument #0 to 'unregister' (namespace '${namespace}' not registered)`\n            );\n        }\n\n        super.delete(namespace);\n        this.EVENT_UNREGISTERED.dispatch({namespace, storage: node.storage});\n        return this;\n    }\n\n    resolve(uri: string): (V & IRegistryResolveResult) | null {\n        let url: URL;\n        try {\n            url = new URL(uri);\n        } catch (err) {\n            return null;\n        }\n\n        const namespace = url.protocol.slice(0, -1);\n        const node = this.get(namespace);\n        if (!node) return null;\n\n        return {...node, path: url.pathname};\n    }\n}\n"],
  "mappings": "AAGA;AACA;AAJA,8BAmCU;AAAA,EASN;AACI;AATJ,yBAAgB;AAEhB,4BAAmB;AAEnB,2BAAkB;AAElB,8BAAqB;AAMrB,iBAAQ,CAAC;AACL,aAAO,WAAW,WAAW;AAE7B,aAAO,CAAC,WAAW;AAAA;AAAA;AAAA,EAGvB;AACI,kBAAc,KAAK;AACnB,oCAAgC;AAC5B,aAAO,WAAW;AAElB,WAAK,mBAAmB,SAAS,CAAC,WAAW;AAAA;AAGjD,UAAM;AAAA;AAAA,EAGV;AACI,QAAI,KAAK,IAAI;AACT,YAAM,IAAI,MACN,6CAA6C;AAAA;AAKrD,iBAAgB,CAAC,WAAW;AAC5B,UAAM,IAAI,WAAW;AAErB,YAAQ,cAAc,UAAU,MAAM,KAAK,cAAc,SAAS,CAAC,WAAW;AAC9E,YAAQ,gBAAgB,UAAU,MAC9B,KAAK,gBAAgB,SAAS,CAAC,WAAW;AAG9C,SAAK,iBAAiB,SAAS,CAAC,WAAW;AAC3C,WAAO;AAAA;AAAA,EAGX;AACI,iBAAa,KAAK,IAAI;AACtB,QAAI,CAAC;AACD,YAAM,IAAI,MACN,+CAA+C;AAAA;AAIvD,UAAM,OAAO;AACb,SAAK,mBAAmB,SAAS,CAAC,WAAW,SAAS,KAAK;AAC3D,WAAO;AAAA;AAAA,EAGX;AACI;AACA;AACI,YAAM,IAAI,IAAI;AAAA;AAEd,aAAO;AAAA;AAGX,sBAAkB,IAAI,SAAS,MAAM,GAAG;AACxC,iBAAa,KAAK,IAAI;AACtB,QAAI,CAAC;AAAM,aAAO;AAElB,WAAO,IAAI,MAAM,MAAM,IAAI;AAAA;AAAA;",
  "names": []
}
