{
  "version": 3,
  "sources": ["../../src/overlays/file_system.ts"],
  "sourcesContent": ["import {BaseAdapter, IQueryResult, IURLObject, IWatchEvent} from \"../adapters/base_adapter\";\nimport {NODE_CHANGES, NODE_TYPES} from \"../util/constants\";\nimport {decode_utf8, encode_utf8} from \"../util/encoding\";\nimport {IEvent, event} from \"../util/event\";\nimport {dirname, join, normalize} from \"../util/path\";\nimport {IJSONReplacer, IJSONReviver, IJSONValue} from \"../util/types\";\n\nimport {BaseOverlay} from \"./base_overlay\";\n\n/**\n * ...\n *\n * @internal\n */\ntype IScopeJoin = (part: string) => string;\n\n/**\n * Represents a scope of the File System that should prefix all operation paths\n */\nexport type IFileSystemScope = IScopeJoin | string;\n\n/**\n * Represents the struct returned to queries and events as a result\n */\nexport interface IFileSystemEntryResult {\n    /**\n     * Represents that the File System Entry is a Directory\n     */\n    is_directory: boolean;\n\n    /**\n     * Represents that the File System Entry is a File\n     */\n    is_file: boolean;\n\n    /**\n     * Represents the associated path of the File System Entry\n     */\n    path: string;\n}\n\n/**\n * Represents the metadata of a File System Entry\n */\nexport interface IFileSystemEntryStats {\n    /**\n     * Represents a timestamp in milliseconds since UNIX Epoch when the File System Entry was created\n     */\n    ctime: number;\n\n    /**\n     * Represents that the File System Entry is a Directory\n     */\n    is_directory: boolean;\n\n    /**\n     * Represents that the File System Entry is a File\n     */\n    is_file: boolean;\n\n    /**\n     * Represents the associated path of the File System Entry\n     */\n    path: string;\n\n    /**\n     * Represents a timestamp in milliseconds since UNIX Epoch when the File System Entry was last modified\n     */\n    mtime: number;\n}\n\n/**\n * Represents the options passable to [[FileSystemOverlay]]\n */\nexport interface IFileSystemOptions {\n    /**\n     * Represents the prefixing path scope the File System should operate at\n     *\n     * > **NOTE**: When used, [[IFileSystemQueryOptions.regex]] will not respect the configured value\n     */\n    scope: IFileSystemScope;\n}\n\n/**\n * Represents the options passable to [[FileSystemOverlay.read_directory]]\n */\nexport interface IFileSystemQueryOptions {\n    /**\n     * Represents to only query for File System Entries that are Directories\n     */\n    is_directory?: boolean;\n\n    /**\n     * Represents to only query for File System Entries that are Files\n     */\n    is_file?: boolean;\n\n    /**\n     * Represents a [Bash Shell Glob](https://en.wikipedia.org/wiki/Glob_(programming)) pattern to match paths with\n     *\n     * > **NOTE**: When using \"Globstar\", \"**\", the backend will search recursively for sub-paths, which may incur a performance penalty\n     */\n    glob?: string;\n\n    /**\n     * Represents a Directory path to read File System Entries from\n     */\n    path?: string;\n\n    /**\n     * Represents if the [[IFileSystemQueryOptions.path]] option should recursively search in child Directories too\n     *\n     * > **NOTE**: When set to `true`, the backend will search recursively for children, which may incur a performance penalty\n     */\n    recursive?: boolean;\n\n    /**\n     * Represents a [Regular Expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to match paths with\n     *\n     * > **NOTE**: When using the \"Global Match\" flag, \"g\", the backend will search recursively for children, which may incur a performance penalty\n     */\n    regex?: RegExp;\n}\n\n/**\n * Represents the options passable to [[FileSystemOverlay.remove_directory]]\n */\nexport interface IFileSystemRemoveOptions {\n    /**\n     * Represents if children of the File System Directory should be removed as well\n     *\n     * > **NOTE**: If set to `false`, the dispatch will fail if sub-paths are found\n     */\n    recursive?: boolean;\n}\n\n/**\n * Represents the event details dispatched to subscribers via [[FileSystemOverlay.watch_directory]] / [[FileSystemOverlay.watch_file]]\n */\nexport interface IFileSystemWatchEvent {\n    /**\n     * Represents what method was used to create / update the Directory / File\n     */\n    change: FILE_SYSTEM_CHANGES;\n\n    /**\n     * Represents the path of the Directory / File that was created / updated\n     */\n    path: string;\n\n    /**\n     * Represents the type of Directory / File that was created / updated\n     */\n    type: NODE_TYPES;\n}\n\n/**\n * Represents the options passable to [[FileSystemOverlay.watch_directory]]\n */\nexport interface IFileSystemWatchOptions {\n    /**\n     * Represents if watcher should recursively watch for changes in child Directories too\n     *\n     * > **NOTE**: When set to `true`, the backend will watch recursively for children, which may incur a performance penalty\n     */\n    recursive?: boolean;\n}\n\n/**\n * Represents that can be applied to a Directory / File on the File System\n */\nexport enum FILE_SYSTEM_CHANGES {\n    /**\n     * Represents when a Directory / File was created\n     */\n    created = \"CHANGE_CREATED\",\n\n    /**\n     * Represents when a Directory / File was removed\n     */\n    removed = \"CHANGE_REMOVED\",\n\n    /**\n     * Represents when a Directory / File had its contents updated\n     */\n    updated = \"CHANGE_UPDATED\",\n}\n\n/**\n * ...\n *\n * @internal\n */\nconst PATTERN_SEPARATOR_SEARCH = /\\//g;\n\n/**\n * ...\n *\n * @internal\n *\n * @param part\n */\nconst SCOPE_NOOP = (part: string) => part;\n\n/**\n * ...\n *\n * @internal\n *\n * @param path\n */\nfunction count_slashes(path: string): number {\n    const matches = path.match(PATTERN_SEPARATOR_SEARCH);\n\n    if (!matches) return 0;\n    return matches.length;\n}\n\n/**\n * ...\n *\n * @internal\n *\n * @param options\n */\nfunction FileSystemOptions(options: Partial<IFileSystemOptions> = {}): IFileSystemOptions {\n    let {scope = SCOPE_NOOP} = options;\n\n    if (typeof scope === \"string\") {\n        const prefix = normalize(scope);\n\n        scope = (part) => join(prefix, part);\n    }\n\n    return {scope};\n}\n\n/**\n * Represents a URIStorage Overlay that treats the configured Adapter as a psuedo File System\n */\nexport class FileSystemOverlay extends BaseOverlay {\n    /**\n     * Represents the join function used for prefixing paths with the scope\n     *\n     * @internal\n     */\n    scope: IScopeJoin;\n\n    /**\n     * Represents the standardized options passed into the constructor\n     */\n    options: IFileSystemOptions;\n\n    constructor(adapter: BaseAdapter, options: Partial<IFileSystemOptions> = {}) {\n        super(adapter);\n\n        this.options = FileSystemOptions(options);\n        this.scope = this.options.scope as IScopeJoin;\n    }\n\n    /**\n     * Returns a new [[FileSystemOverlay]] instance scoped to the given `path`\n     * @param path\n     */\n    create_scope(path: string): FileSystemOverlay {\n        const filesystem = new FileSystemOverlay(this.adapter, {\n            scope: this.scope(path),\n        });\n\n        return filesystem;\n    }\n\n    /**\n     * Returns a embedable URL representing a File in the File System\n     *\n     * > **NOTE**: Will not work with if the configured Adapter's [[BaseAdapter.can_hotlink]] is `false`\n     *\n     * @param file_path\n     */\n    async create_url_object(file_path: string): Promise<IURLObject> {\n        if (!this.has_feature(\"can_hotlink\")) {\n            throw new Error(\n                \"bad dispatch to 'create_url_object' (adapter does not support feature)\"\n            );\n        }\n\n        file_path = this.scope(file_path);\n\n        const {adapter} = this;\n        const node = await adapter.get(file_path);\n\n        if (!node) {\n            throw new Error(\"bad argument #0 to 'create_url_object' (file path not found)\");\n        } else if (node.type !== NODE_TYPES.file) {\n            throw new Error(\"bad argument #0 to 'create_url_object' (file path is not a file)\");\n        }\n\n        return adapter.create_url_object(file_path);\n    }\n\n    /**\n     * Creates a new Directory in the File System\n     * @param directory_path\n     */\n    async create_directory(directory_path: string): Promise<void> {\n        if (this.has_feature(\"is_readonly\")) {\n            throw new Error(\n                \"bad dispatch to 'create_directory' (adapter does not support feature)\"\n            );\n        }\n\n        const {adapter} = this;\n\n        directory_path = this.scope(directory_path);\n        directory_path = normalize(directory_path);\n        if (directory_path === \"/\") {\n            throw new Error(\n                \"bad argument #0 to 'create_directory' (directory path is already a directory)\"\n            );\n        }\n\n        const node = await adapter.get(directory_path);\n        if (node) {\n            switch (node.type) {\n                case NODE_TYPES.directory:\n                    throw new Error(\n                        \"bad argument #0 to 'create_directory' (directory path is already a directory)\"\n                    );\n\n                case NODE_TYPES.file:\n                    throw new Error(\n                        \"bad argument #0 to 'create_directory' (directory path is already a file)\"\n                    );\n            }\n        }\n\n        const parent_path = dirname(directory_path);\n        if (parent_path !== \"/\") {\n            const parent_node = await adapter.get(parent_path);\n            if (!parent_node) {\n                throw new Error(\n                    \"bad argument #0 to 'create_directory' (parent path does not exist)\"\n                );\n            } else if (parent_node.type !== NODE_TYPES.directory) {\n                throw new Error(\n                    \"bad argument #0 to 'create_directory' (parent path is not a directory)\"\n                );\n            }\n        }\n\n        return adapter.put(directory_path, NODE_TYPES.directory);\n    }\n\n    /**\n     * Returns if a given Entry exists on the File System\n     * @param path\n     */\n    async exists(path: string): Promise<boolean> {\n        path = this.scope(path);\n        const node = await this.adapter.get(path);\n\n        return !!node;\n    }\n\n    /**\n     * Returns the File System metadata about a given Entry\n     * @param path\n     */\n    async get_stats(path: string): Promise<IFileSystemEntryStats> {\n        path = this.scope(path);\n        const node = await this.adapter.get(path);\n        if (!node) {\n            throw new Error(\"bad argument #0 to 'get_stats' (path not found)\");\n        }\n\n        return {\n            ctime: node.ctime,\n            path: node.path,\n            mtime: node.mtime,\n\n            is_directory: node.type === NODE_TYPES.directory,\n            is_file: node.type === NODE_TYPES.file,\n        };\n    }\n\n    /**\n     * Returns entries queried from the File System, with optional filters\n     * @param options\n     */\n    async read_directory(options: IFileSystemQueryOptions = {}): Promise<IFileSystemEntryResult[]> {\n        const {adapter} = this;\n        const {is_directory, is_file, glob, regex, path, recursive = false} = options;\n\n        let type: NODE_TYPES | NODE_TYPES[];\n        if (is_directory) type = NODE_TYPES.directory;\n        else if (is_file) type = NODE_TYPES.file;\n        else type = [NODE_TYPES.directory, NODE_TYPES.file];\n\n        // TODO: Should we perform a sanity check for the `.type` parameter? Making\n        // sure that end-developers can't pass non-File System appropriate types?\n\n        let results: IQueryResult[];\n        if (path || path === \"\") {\n            let directory_path = this.scope(path);\n            directory_path = normalize(directory_path);\n\n            const node = await adapter.get(directory_path);\n\n            if (directory_path !== \"/\") {\n                if (!node) {\n                    throw new Error(\n                        \"bad option 'IFileSystemQueryOptions.path' to 'read_directory' (directory path not found)\"\n                    );\n                } else if (node.type !== NODE_TYPES.directory) {\n                    throw new Error(\n                        \"bad option 'IFileSystemQueryOptions.path' to 'read_directory' (directory path is not a directory)\"\n                    );\n                }\n            }\n\n            results = await adapter.query({\n                type,\n                path: {\n                    recursive,\n                    path: directory_path,\n                },\n            });\n        } else if (glob) {\n            results = await adapter.query({\n                type,\n                path: {\n                    // NOTE: This **should** work, hopefully not missing any edge cases\n                    glob: this.scope(glob),\n                },\n            });\n        } else if (regex) {\n            results = await adapter.query({\n                type,\n                path: {regex},\n            });\n        } else {\n            results = await adapter.query({\n                type,\n                path: {\n                    recursive,\n                    path: this.scope(\"/\"),\n                },\n            });\n        }\n\n        return results.map((result, index) => {\n            const {path, type} = result;\n\n            return {\n                path,\n\n                is_directory: type === NODE_TYPES.directory,\n                is_file: type === NODE_TYPES.file,\n            };\n        });\n    }\n\n    /**\n     * Returns a `Uint8Array` a File in the File System\n     * @param file_path\n     */\n    async read_file(file_path: string): Promise<Uint8Array> {\n        const {adapter} = this;\n        file_path = this.scope(file_path);\n\n        const node = await adapter.get(file_path);\n        if (!node) {\n            throw new Error(\"bad argument #0 to 'read_file' (file path not found)\");\n        } else if (node.type !== NODE_TYPES.file) {\n            throw new Error(\"bad argument #0 to 'read_file' (file path is not a file)\");\n        }\n\n        const payload = await adapter.read(file_path);\n        return payload ? payload : new Uint8Array();\n    }\n\n    /**\n     * Removes a Directory from the File System\n     *\n     * > **NOTE**: If [[IFileSystemRemoveOptions.recursive]] to `false`, the dispatch will fail if sub-paths are found\n     *\n     * @param directory_path\n     * @param options\n     */\n    async remove_directory(\n        directory_path: string,\n        options: IFileSystemRemoveOptions = {}\n    ): Promise<boolean> {\n        if (this.has_feature(\"is_readonly\")) {\n            throw new Error(\n                \"bad dispatch to 'remove_directory' (adapter does not support feature)\"\n            );\n        }\n\n        const {adapter} = this;\n        const {recursive = false} = options;\n\n        directory_path = this.scope(directory_path);\n        directory_path = normalize(directory_path);\n        if (directory_path === \"/\") {\n            throw new Error(\"bad argument #0 to 'remove_directory' (directory path not found)\");\n        }\n\n        const node = await adapter.get(directory_path);\n        if (!node) {\n            throw new Error(\"bad argument #0 to 'remove_directory' (directory path not found)\");\n        } else if (node.type !== NODE_TYPES.directory) {\n            throw new Error(\n                \"bad argument #0 to 'remove_directory' (directory path is not a directory)\"\n            );\n        }\n\n        // TODO: Should recursion functionality be handled by Adapters instead? That\n        // way the underlying backends can be handled with more performant methodologies?\n        const children_results = await adapter.query({\n            path: {\n                path: directory_path,\n                recursive: true,\n            },\n        });\n\n        if (children_results.length > 0) {\n            if (recursive) {\n                children_results.sort((a, b) => count_slashes(b.path) - count_slashes(a.path));\n\n                const promises = children_results.map((result, index) => {\n                    return adapter.remove(result.path);\n                });\n\n                await Promise.all(promises);\n            } else {\n                throw new Error(\n                    \"bad argument #0 to 'remove_directory' (directory contains children)\"\n                );\n            }\n        }\n\n        return adapter.remove(directory_path);\n    }\n\n    /**\n     * Removes a File from the File System\n     * @param file_path\n     */\n    async remove_file(file_path: string): Promise<void> {\n        if (this.has_feature(\"is_readonly\")) {\n            throw new Error(\"bad dispatch to 'remove_file' (adapter does not support feature)\");\n        }\n\n        const {adapter} = this;\n        file_path = this.scope(file_path);\n\n        const node = await adapter.get(file_path);\n        if (!node) {\n            throw new Error(\"bad argument #0 to 'remove_file' (file path not found)\");\n        } else if (node.type !== NODE_TYPES.file) {\n            throw new Error(\"bad argument #0 to 'remove_file' (file path is not a file)\");\n        }\n\n        // TODO: We will never know the \"exact\" reason for this. Should\n        // this be handled differently other than a generic error?\n        const removed = await adapter.remove(file_path);\n        if (!removed) {\n            throw new Error(\"bad argument #0 to 'remove_file' (could not remove file path)\");\n        }\n    }\n\n    /**\n     * Watches a Directory for any changes on the File System\n     * @param directory_path\n     */\n    async watch_directory(\n        directory_path: string,\n        options: IFileSystemWatchOptions = {}\n    ): Promise<IEvent<IFileSystemWatchEvent>> {\n        if (!this.has_feature(\"can_watch\")) {\n            throw new Error(\"bad dispatch to 'watch_directory' (adapter does not support feature)\");\n        }\n\n        const {adapter} = this;\n        const {recursive} = options;\n\n        directory_path = this.scope(directory_path);\n        directory_path = normalize(directory_path);\n        if (directory_path !== \"/\") {\n            const node = await adapter.get(directory_path);\n\n            if (!node) {\n                throw new Error(\"bad argument #0 to 'watch_directory' (directory path not found)\");\n            } else if (node.type !== NODE_TYPES.directory) {\n                throw new Error(\n                    \"bad argument #0 to 'watch_directory' (directory path is not a directory)\"\n                );\n            }\n        }\n\n        const watcher = await adapter.watch({\n            recursive,\n\n            change: [NODE_CHANGES.attached, NODE_CHANGES.created, NODE_CHANGES.removed],\n            inclusive: true,\n            path: directory_path,\n        });\n\n        return event((dispatch) => {\n            const destroy = watcher.subscribe((event) => {\n                switch (event.change) {\n                    case NODE_CHANGES.attached:\n                        dispatch({\n                            change: FILE_SYSTEM_CHANGES.updated,\n                            path: event.path,\n                            type: event.type,\n                        });\n\n                        break;\n\n                    case NODE_CHANGES.created:\n                        dispatch({\n                            change: FILE_SYSTEM_CHANGES.created,\n                            path: event.path,\n                            type: event.type,\n                        });\n\n                        break;\n\n                    case NODE_CHANGES.removed:\n                        dispatch({\n                            change: FILE_SYSTEM_CHANGES.removed,\n                            path: event.path,\n                            type: event.type,\n                        });\n\n                        break;\n                }\n            });\n\n            return () => destroy();\n        });\n    }\n\n    /**\n     * Watches a File for any changes on the File System\n     * @param file_path\n     */\n    async watch_file(file_path: string): Promise<IEvent<IFileSystemWatchEvent>> {\n        if (!this.has_feature(\"can_watch\")) {\n            throw new Error(\"bad dispatch to 'watch_file' (adapter does not support feature)\");\n        }\n\n        const {adapter} = this;\n        file_path = this.scope(file_path);\n\n        const node = await adapter.get(file_path);\n        if (!node) {\n            throw new Error(\"bad argument #0 to 'watch_file' (file path not found)\");\n        } else if (node.type !== NODE_TYPES.file) {\n            throw new Error(\"bad argument #0 to 'watch_file' (file path is not a file)\");\n        }\n\n        const watcher = await adapter.watch({\n            change: [NODE_CHANGES.attached, NODE_CHANGES.removed],\n            path: file_path,\n        });\n\n        return event((dispatch) => {\n            async function update(event: IWatchEvent) {\n                switch (event.change) {\n                    case NODE_CHANGES.attached:\n                        dispatch({\n                            change: FILE_SYSTEM_CHANGES.updated,\n                            path: event.path,\n                            type: event.type,\n                        });\n\n                        break;\n\n                    case NODE_CHANGES.removed:\n                        dispatch({\n                            change: FILE_SYSTEM_CHANGES.removed,\n                            path: event.path,\n                            type: event.type,\n                        });\n\n                        break;\n                }\n            }\n\n            const destroy = watcher.subscribe(update);\n            return () => destroy();\n        });\n    }\n\n    /**\n     * Writes a `Uint8Array` payload to a File. Creating a new File in the File System, if not previously made\n     * @param file_path\n     * @param payload\n     */\n    async write_file(file_path: string, payload: Uint8Array): Promise<void> {\n        if (this.has_feature(\"is_readonly\")) {\n            throw new Error(\"bad dispatch to 'write_file' (adapter does not support feature)\");\n        }\n\n        const {adapter} = this;\n\n        file_path = this.scope(file_path);\n        file_path = normalize(file_path);\n        if (file_path === \"/\") {\n            throw new Error(\"bad argument #0 to 'write_file' (file path is not a file)\");\n        }\n\n        const node = await adapter.get(file_path);\n        if (node && node.type !== NODE_TYPES.file) {\n            throw new Error(\"bad argument #0 to 'write_file' (file path is not a file)\");\n        }\n\n        const parent_path = dirname(file_path);\n        if (parent_path !== \"/\") {\n            const parent_node = await adapter.get(parent_path);\n            if (!parent_node || parent_node.type !== NODE_TYPES.directory) {\n                throw new Error(\"bad argument #0 to 'write_file' (parent path is not a directory)\");\n            }\n        }\n\n        await adapter.put(file_path, NODE_TYPES.file);\n        return adapter.write(file_path, payload);\n    }\n\n    /**\n     * Returns parsed JSON read from the given `file_path`\n     * @param file_path\n     * @param reviver\n     */\n    async read_file_json<T extends IJSONValue = IJSONValue>(\n        file_path: string,\n        reviver?: IJSONReviver\n    ): Promise<T> {\n        const encoded = await this.read_file_text(file_path);\n\n        return JSON.parse(encoded, reviver);\n    }\n\n    /**\n     * Returns UTF-8 text read from the given `file_path`\n     * @param file_path\n     */\n    async read_file_text(file_path: string): Promise<string> {\n        const payload = await this.read_file(file_path);\n\n        return decode_utf8(payload);\n    }\n\n    /**\n     * Writes to the given `file_path`, encoding `value` as JSON text\n     * @param file_path\n     * @param value\n     * @param replacer\n     * @param space\n     */\n    write_file_json<T extends IJSONValue = IJSONValue>(\n        file_path: string,\n        value: T,\n        replacer?: IJSONReplacer,\n        space?: number | string\n    ): Promise<void> {\n        const encoded = JSON.stringify(value, replacer, space);\n\n        return this.write_file_text(file_path, encoded);\n    }\n\n    /**\n     * Writes to the given `file_path`, encoding `text` as UTF-8 bytes\n     * @param file_path\n     * @param text\n     */\n    write_file_text(file_path: string, text: string): Promise<void> {\n        const encoded = encode_utf8(text);\n\n        return this.write_file(file_path, encoded);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
